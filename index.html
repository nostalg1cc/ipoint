<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
  <title>IPoint</title>

  <!-- PWA Meta Tags -->
  <meta name="description" content="Track your IP address location, ISP, and connection changes with real-time monitoring and kill-switch security alerts.">
  <meta name="theme-color" content="#0f1115">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="IPoint">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="application-name" content="IPoint">

  <!-- PWA Manifest -->
  <link rel="manifest" href="data:application/json;charset=utf-8;base64,ewogICJuYW1lIjogIklQb2ludCAtIElQIEFkZHJlc3MgVHJhY2tlciIsCiAgInNob3J0X25hbWUiOiAiSVBvaW50IiwKICAiZGVzY3JpcHRpb24iOiAiVHJhY2sgeW91ciBJUCBhZGRyZXNzIGxvY2F0aW9uLCBJU1AsIGFuZCBjb25uZWN0aW9uIGNoYW5nZXMgd2l0aCByZWFsLXRpbWUgbW9uaXRvcmluZy4iLAogICJzdGFydF91cmwiOiAiLyIsCiAgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsCiAgImJhY2tncm91bmRfY29sb3IiOiAiIzBmMTExNSIsCiAgInRoZW1lX2NvbG9yIjogIiMwZjExMTUiLAogICJvcmllbnRhdGlvbiI6ICJwb3J0cmFpdC1wcmltYXJ5IiwKICAiaWNvbnMiOiBbCiAgICB7CiAgICAgICJzcmMiOiAiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TlRZaUlHaGxhV2RvZEQwaU1qVTJJajQ4Y21WamRDQjNhV1IwYUQwaU1qVTJJaUJvWldsbmFIUTlJakkxTmlJZ1ptbHNiRDBpSXpCbU1URXhOU0l2UGp4amFYSmpiR1VnWTNnOUlqRXlPQ0lnWTNrOUlqRXlPQ0lnY2owaU5EQWlJR1pwYkd3OUlpTTNZV0V5Wm1ZaUx6NDhkR1Y0ZENCNFBTSXhNamdpSUhrOUlqRXlOQ0lnZEdWNGRDMWhibU5vYjNJOUltMXBaR1JzWlNJZ1ptbHNiRDBpSTJFMllXWmlaQ0lnWm05dWRDMXphWHBsUFNJeU1DSStTVkE4TDNSbGVIUStQQzl6ZG1jKyIsCiAgICAgICJzaXplcyI6ICIyNTZ4MjU2IiwKICAgICAgInR5cGUiOiAiaW1hZ2Uvc3ZnK3htbCIKICAgIH0sCiAgICB7CiAgICAgICJzcmMiOiAiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0kxTURJaUlHaGxhV2RvZEQwaU5UQXlJajQ4Y21WamRDQjNhV1IwYUQwaU5UQXlJaUJvWldsbmFIUTlJalV3TWlJZ1ptbHNiRDBpSXpCbU1URXhOU0l2UGp4amFYSmpiR1VnWTNnOUlqSTFNU0lnWTNrOUlqSTFNU0lnY2owaU1EQWlJR1pwYkd3OUlpTTNZV0V5Wm1ZaUx6NDhkR1Y0ZENCNFBTSXlOVEVpSUhrOUlqSTBOeUlnZEdWNGRDMWhibU5vYjNJOUltMXBaR1JzWlNJZ1ptbHNiRDBpSTJFMllXWmlaQ0lnWm05dWRDMXphWHBsUFNJME5DSStTVkE4TDNSbGVIUStQQzl6ZG1jKyIsCiAgICAgICJzaXplcyI6ICI1MTJ4NTEyIiwKICAgICAgInR5cGUiOiAiaW1hZ2Uvc3ZnK3htbCIKICAgIH0KICBdCn0=">

  <!-- Favicon updates to the current country flag -->
  <link rel="icon" type="image/png" sizes="16x16" href="https://flagsapi.com/US/flat/16.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://flagsapi.com/US/flat/32.png">
  <link rel="icon" type="image/png" sizes="64x64" href="https://flagsapi.com/US/flat/64.png">

  <!-- Apple Touch Icons -->
  <link rel="apple-touch-icon" sizes="180x180" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxODAiIGhlaWdodD0iMTgwIj48cmVjdCB3aWR0aD0iMTgwIiBoZWlnaHQ9IjE4MCIgZmlsbD0iIzBmMTExNSIvPjxjaXJjbGUgY3g9IjkwIiBjeT0iOTAiIHI9IjMwIiBmaWxsPSIjN2FhMmZmIi8+PHRleHQgeD0iOTAiIHk9Ijk1IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjYTZhZmJkIiBmb250LXNpemU9IjE2Ij5JUDwvdGV4dD48L3N2Zz4=">

  <!-- Flag icons (ISO country codes) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flag-icons/css/flag-icons.min.css">

  <!-- Leaflet for maps -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    /* Drag and Drop Styles */
    .grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      margin: 10px;
      gap: 10px;
    }
    
    .grid.dragging {
      cursor: grabbing;
    }
    
    .kv {
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      padding: 10px;
      border-radius: 10px;
      background: var(--kv-bg);
      transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
      cursor: grab;
      user-select: none;
    }
    
    /* Alternating background colors for better differentiation */
    .kv:nth-child(even) {
      background: var(--kv-bg-alt, var(--kv-bg));
    }
    
    .kv:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    
    .kv.dragging {
      cursor: grabbing;
      transform: scale(1.1);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      opacity: 0.9;
    }
    
    .kv.drag-over {
      border: 2px dashed var(--accent);
      background: var(--accent)10;
    }
    
    .kv.drag-placeholder {
      opacity: 0.5;
      background: var(--line);
      border: 2px dashed var(--muted);
    }
    
    /* Settings Popup Styles */
    .settings-popup {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      backdrop-filter: blur(8px);
      z-index: 2000;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    
    .settings-popup.visible {
      display: flex;
    }
    
    .settings-content {
      background: var(--card-bg);
      border-radius: 20px;
      padding: 24px;
      max-width: 500px;
      width: 100%;
      max-height: 80vh;
      overflow-y: auto;
      position: relative;
      box-shadow: 0 20px 60px rgba(0,0,0,0.4);
    }
    
    .settings-content::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      padding: 2px;
      background: var(--card-border);
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      pointer-events: none;
      z-index: -1;
    }
    
    .settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--line);
    }
    
    .settings-title {
      font-size: 18px;
      font-weight: 700;
      color: var(--text);
    }
    
    .settings-close {
      background: none;
      border: none;
      color: var(--muted);
      font-size: 24px;
      cursor: pointer;
      padding: 4px;
      border-radius: 8px;
      transition: all 0.2s ease;
    }
    
    .settings-close:hover {
      background: var(--hover-bg);
      color: var(--text);
    }
    
    .settings-section {
      margin-bottom: 24px;
    }
    
    .settings-section-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .settings-group {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .settings-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    
    .settings-label {
      font-size: 13px;
      color: var(--text);
      font-weight: 500;
    }
    
    .settings-input {
      background: var(--button-bg);
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 8px 12px;
      color: var(--text);
      font-size: 13px;
      transition: all 0.2s ease;
      min-width: 120px;
    }
    
    .settings-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent)20;
    }
    
    .color-picker {
      width: 40px;
      height: 32px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      background: none;
    }
    
    .theme-preview {
      width: 100%;
      height: 60px;
      border-radius: 8px;
      border: 1px solid var(--line);
      margin-top: 8px;
      position: relative;
      overflow: hidden;
    }
    
    .theme-preview::before {
      content: "";
      position: absolute;
      inset: 0;
      background: var(--bg);
      opacity: 0.8;
    }
    
    .theme-preview::after {
      content: "";
      position: absolute;
      inset: 8px;
      background: var(--accent);
      border-radius: 4px;
      opacity: 0.6;
    }
    
    .settings-button {
      background: var(--button-bg);
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 8px 16px;
      color: var(--text);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 500;
    }
    
    .settings-button:hover {
      background: var(--button-hover);
      transform: translateY(-1px);
    }
    
    .settings-button.primary {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
    
    .settings-button.primary:hover {
      background: var(--accent);
      opacity: 0.9;
    }
    
    .settings-button-group {
      display: flex;
      gap: 8px;
      margin-top: 16px;
    }
    
    .settings-toggle {
      position: relative;
      width: 44px;
      height: 24px;
      background: var(--line);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .settings-toggle.active {
      background: var(--accent);
    }
    
    .settings-toggle::after {
      content: "";
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      background: white;
      border-radius: 50%;
      transition: all 0.2s ease;
    }
    
    .settings-toggle.active::after {
      transform: translateX(20px);
    }
    
    /* OLED Black Theme */
    [data-theme="oled"] {
      --bg: #000000; 
      --panel: #000000; 
      --text: #ffffff; 
      --muted: #666666; 
      --accent: #00ff00;
      --good: #00ff00; 
      --warn: #ffff00; 
      --bad: #ff0000; 
      --line: #333333;
      --map-filter: grayscale(100%) contrast(150%);
      --card-bg: rgba(0, 0, 0, 0.8);
      --card-border: linear-gradient(to bottom right, rgba(0,255,0,.2), rgba(0,255,0,.05));
      --kv-bg: rgba(0, 0, 0, 0.6);
      --kv-bg-alt: rgba(0, 0, 0, 0.4);
      --kv-border: linear-gradient(to bottom right, rgba(0,255,0,.15), rgba(0,255,0,.03));
      --table-border: rgba(0,255,0,.2);
      --hover-bg: rgba(255,255,255,0.05);
      --shade-bg: radial-gradient(1200px 800px at 50% 20%, transparent 0%, rgba(0,0,0,0.8) 60%, rgba(0,0,0,0.95) 100%);
      --badge-bg: rgba(255,255,255,0.1);
      --button-bg: #111111;
      --button-hover: #222222;
      --changed-bg: linear-gradient(90deg, rgba(255,255,0,0.1), transparent 80%);
      --changed-hover: linear-gradient(90deg, rgba(255,255,0,0.15), transparent 80%);
      --security-bg: linear-gradient(90deg, rgba(255,0,0,0.1), transparent 80%);
      --security-hover: linear-gradient(90deg, rgba(255,0,0,0.15), transparent 80%);
      --speedtest-bg: linear-gradient(90deg, rgba(0,255,0,0.1), transparent 80%);
      --speedtest-hover: linear-gradient(90deg, rgba(0,255,0,0.15), transparent 80%);
    }
    
    /* Tooltip/popup styles */
    .date-popup {
      position: fixed;
      background: var(--card-bg);
      border-radius: 20px;
      padding: 16px 20px;
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease, transform 0.3s ease;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3), 0 4px 16px rgba(0,0,0,0.2);
      white-space: nowrap;
      font-size: 13px;
      backdrop-filter: blur(8px) saturate(120%);
      max-width: 300px;
      overflow: hidden;
    }
    
    .date-popup::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      padding: 2px;
      background: var(--card-border);
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      pointer-events: none;
      z-index: -1;
      transition: background 0.3s ease;
    }
    
    .date-popup.visible {
      opacity: 1;
    }
    
    .date-popup-content {
      display: flex;
      flex-direction: column;
      gap: 8px;
      text-align: left;
      position: relative;
      z-index: 1;
    }
    
    .date-popup-time {
      color: var(--text);
      font-weight: 700;
      font-size: 15px;
      line-height: 1.4;
    }
    
    .date-popup-ago {
      color: var(--muted);
      font-size: 12px;
      font-weight: 500;
      opacity: 0.9;
    }
    
    /* Make date cells interactive */
    td.date-cell {
      position: relative;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    
    td.date-cell:hover {
      background-color: var(--hover-bg);
    }
    
    :root{
      --bg:#0f1115; --panel:#151923; --text:#e7e9ee; --muted:#a6afbd; --accent:#7aa2ff;
      --good:#35c48b; --warn:#f5b64d; --bad:#ef6a6a; --line:#232a36;
      --map-filter: grayscale(100%);
      --card-bg: rgba(150, 161, 196, 0.062);
      --card-border: linear-gradient(to bottom right,rgba(108,99,134,.25),rgba(108,99,134,.05));
      --kv-bg: rgba(150, 161, 196, 0.04);
      --kv-bg-alt: rgba(150, 161, 196, 0.02);
      --kv-border: linear-gradient(to bottom right,rgba(108,99,134,.2),rgba(108,99,134,.04));
      --table-border: rgba(108,99,134,.25);
      --hover-bg: #ffffff05;
      --shade-bg: radial-gradient(1200px 800px at 50% 20%, transparent 0%, rgba(15,17,21,0.35) 60%, rgba(15,17,21,0.6) 100%);
      --badge-bg: #ffffff10;
      --button-bg: #1a2230;
      --button-hover: #20293a;
      --changed-bg: linear-gradient(90deg,#ffb74a12,transparent 80%);
      --changed-hover: linear-gradient(90deg,#ffb74a1c,transparent 80%);
      --security-bg: linear-gradient(90deg,#dc262620,transparent 80%);
      --security-hover: linear-gradient(90deg,#dc262630,transparent 80%);
      --speedtest-bg: linear-gradient(90deg,#7aa2ff20,transparent 80%);
      --speedtest-hover: linear-gradient(90deg,#7aa2ff30,transparent 80%);
      
      /* Custom tinting variables */
      --tint-hue: 220;
      --tint-saturation: 70%;
      --tint-lightness: 60%;
      --tint-alpha: 0.1;
    }

    [data-theme="light"] {
      --bg: #f1f3f6; --panel: #fafbfc; --text: #2d3748; --muted: #718096; --accent: #4299e1;
      --good: #38a169; --warn: #ed8936; --bad: #e53e3e; --line: #d2d6dc;
      --map-filter: none;
      --card-bg: rgba(250, 251, 252, 0.85);
      --card-border: linear-gradient(to bottom right, rgba(160, 174, 192, 0.25), rgba(160, 174, 192, 0.08));
      --kv-bg: rgba(237, 242, 247, 0.5);
      --kv-bg-alt: rgba(237, 242, 247, 0.3);
      --kv-border: linear-gradient(to bottom right, rgba(160, 174, 192, 0.2), rgba(160, 174, 192, 0.04));
      --table-border: rgba(160, 174, 192, 0.1);
      --hover-bg: rgba(237, 242, 247, 0.4);
      --shade-bg: radial-gradient(1200px 800px at 50% 20%, transparent 0%, rgba(241, 243, 246, 0.25) 60%, rgba(241, 243, 246, 0.4) 100%);
      --badge-bg: rgba(160, 174, 192, 0.08);
      --button-bg: #edf2f7;
      --button-hover: #e2e8f0;
      --changed-bg: linear-gradient(90deg, rgba(237, 137, 54, 0.12), transparent 80%);
      --changed-hover: linear-gradient(90deg, rgba(237, 137, 54, 0.2), transparent 80%);
      --security-bg: linear-gradient(90deg, rgba(229, 62, 62, 0.12), transparent 80%);
      --security-hover: linear-gradient(90deg, rgba(229, 62, 62, 0.2), transparent 80%);
      --speedtest-bg: linear-gradient(90deg, rgba(66, 153, 225, 0.12), transparent 80%);
      --speedtest-hover: linear-gradient(90deg, rgba(66, 153, 225, 0.2), transparent 80%);
    }

    html,body{height:100%}
    
    /* PWA and Standalone app adjustments */
    @media (display-mode: standalone) {
      body { padding-top: env(safe-area-inset-top); }
      main { padding-bottom: env(safe-area-inset-bottom); }
    }

    /* iOS Safari specific adjustments */
    @supports (-webkit-touch-callout: none) {
      body { -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
      input, textarea, button { -webkit-user-select: auto; user-select: auto; }
      body { padding-top: constant(safe-area-inset-top); padding-top: env(safe-area-inset-top); }
      main { padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom); }
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,Segoe UI,Roboto,Inter,Arial,sans-serif;position:relative;transition:background-color 0.3s ease, color 0.3s ease}

    /* Soft background map with parallax */
    #mapbg{position:fixed; inset:0; z-index:0; opacity:0.85; pointer-events:none; filter:var(--map-filter); transition: transform 0.3s ease-out, filter 0.3s ease;} 
    #shade{position:fixed; inset:0; z-index:1; background: var(--shade-bg); pointer-events:none; transition: background 0.3s ease;}

    main{position:relative; z-index:2; max-width:1100px;margin:20px auto;padding:16px;display:grid;gap:16px}

    /* Mobile responsive adjustments */
    @media (max-width: 768px) {
      main{margin:10px auto;padding:12px;gap:12px}
      body{font-size:13px}
    }

    /* Glass cards + gradient border */
    .card{position:relative;overflow:hidden;background:var(--card-bg);border-radius:20px;padding:0px;backdrop-filter:blur(8px) saturate(120%);z-index:0;transition:background 0.3s ease}
    .card::before{content:"";position:absolute;inset:0;border-radius:inherit;padding:2px;background:var(--card-border);
      -webkit-mask:linear-gradient(#fff 0 0) content-box,linear-gradient(#fff 0 0);
      mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;mask-composite:exclude;pointer-events:none;z-index:-1;transition:background 0.3s ease}
    
    /* Apply tinting to cards */
    .card::after{content:"";position:absolute;inset:0;border-radius:inherit;background:hsla(var(--tint-hue), var(--tint-saturation), var(--tint-lightness), var(--tint-alpha));pointer-events:none;z-index:1;transition:background 0.3s ease}

    
    /* Mobile responsive grid - always 2 columns on mobile */
    @media (max-width: 768px) {
      .grid{grid-template-columns:repeat(2,1fr);margin:8px;gap:8px}
    }

    /* Removed border since alternating backgrounds provide differentiation */
    .kv::after{content:"";position:absolute;inset:0;border-radius:inherit;background:hsla(var(--tint-hue), var(--tint-saturation), var(--tint-lightness), calc(var(--tint-alpha) * 0.3));pointer-events:none;z-index:0;transition:background 0.3s ease}
    .kv:has(#miniMap) { padding: 0; }
    
    /* Mobile responsive kv */
    @media (max-width: 768px) {
      .kv{padding:8px}
    }

    .k{color:var(--muted);font-size:12px;margin-bottom:6px;transition:color 0.3s ease}
    .v{font-weight:600;word-break:break-word;transition:color 0.3s ease;
       /* Text truncation for single paragraph */
       white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:100%}
    
    /* Mobile responsive text */
    @media (max-width: 768px) {
      .k{font-size:11px;margin-bottom:4px}
      .v{font-size:13px}
    }

    .row{display:flex;align-items:center;padding:10px;gap:10px;flex-wrap:wrap}
    
    /* Mobile responsive row */
    @media (max-width: 768px) {
      .row{padding:8px;gap:8px;flex-direction:column;align-items:flex-start}
      .row:first-child{flex-direction:row;align-items:center}
    }

    .flag{display:inline-flex;width:28px;height:20px;border-radius:3px;overflow:hidden;box-shadow:0 0 0 1px #00000020}
    
    /* Mobile responsive flag */
    @media (max-width: 768px) {
      .flag{width:24px;height:18px}
    }

    .badge{
      font-size: 12px;
      padding: 6px 8px;
      border-radius: 20px;
      border: 1px solid var(--line);
      background: var(--badge-bg);
      transition: all 0.3s ease;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 28px;
      box-sizing: border-box;
    }
    .badge.good{border-color:#1b7b59;background:#1b7b5918;color:#87f1c7}
    .badge.warn{border-color:#7b5a1b;background:#7b5a1b18;color:#ffdca3}
    .badge.bad{border-color:#7b1b1b;background:#7b1b1b18;color:#ffbdbd}
    .badge.neutral{border-color:#2a2f3b;background:#2a2f3b66;color:#c9cfdb}
    .badge.security{border-color:#b91c1c;background:#b91c1c30;color:#fca5a5;animation:pulse-security 2s infinite}
    .badge.more{border-color:var(--accent);background:var(--accent)20;color:var(--accent);cursor:pointer;transition:all 0.3s ease}
    .badge.more:hover{background:var(--accent)30;transform:translateY(-1px)}

    [data-theme="light"] .badge.good{border-color:#38a169;background:#38a16920;color:#22543d}
    [data-theme="light"] .badge.warn{border-color:#ed8936;background:#ed893620;color:#c05621}
    [data-theme="light"] .badge.bad{border-color:#e53e3e;background:#e53e3e20;color:#c53030}
    [data-theme="light"] .badge.neutral{border-color:#a0aec0;background:#cbd5e140;color:#4a5568}
    [data-theme="light"] .badge.security{border-color:#e53e3e;background:#fed7d740;color:#c53030;animation:pulse-security 2s infinite}
    [data-theme="light"] .badge.more{border-color:var(--accent);background:var(--accent)20;color:var(--accent)}
    [data-theme="light"] .badge.more:hover{background:var(--accent)30}

    /* Badge container responsive styling */
    .badge-container {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      max-width: 100%;
    }
    
    .badge-container.collapsed {
      flex-wrap: nowrap;
      overflow: hidden;
    }
    
    .badge-container.collapsed .badge:not(.more) {
      flex-shrink: 0;
    }
    
    .badge-container.expanded {
      flex-wrap: wrap;
    }
    
    .badge-container .badge.more {
      flex-shrink: 0;
      margin-left: auto;
    }

    /* Mobile responsive badge */
    @media (max-width: 768px) {
      .badge{
        font-size: 11px;
        padding: 5px 6px;
        max-width: 100px;
        min-height: 26px;
      }
      
      .badge-container {
        gap: 4px;
        max-width: 100%;
      }
      
      .badge-container.collapsed {
        max-width: calc(100vw - 40px);
      }
    }
    
    @media (max-width: 480px) {
      .badge{
        font-size: 10px;
        padding: 4px 5px;
        max-width: 80px;
        min-height: 24px;
      }
      
      .badge-container {
        gap: 3px;
      }
    }

    /* Theme toggle button */
    .theme-toggle {
      background: var(--badge-bg);
      border: 1px solid var(--line);
      border-radius: 20px;
      padding: 6px 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
      transition: all 0.3s ease;
      user-select: none;
      min-width: 60px;
      justify-content: center;
      min-height: 28px;
      box-sizing: border-box;
    }
    
    .theme-toggle:hover {
      background: var(--button-hover);
    }

    /* Mobile responsive theme toggle */
    @media (max-width: 768px) {
      .theme-toggle{
        font-size: 11px;
        padding: 5px 6px;
        min-width: 50px;
        min-height: 26px;
      }
    }
    
    @media (max-width: 480px) {
      .theme-toggle{
        font-size: 10px;
        padding: 4px 5px;
        min-width: 45px;
        min-height: 24px;
      }
    }

    @keyframes pulse-security {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    table{width:100%;border-collapse:collapse}
    th,td{padding:10px;border-bottom:.25px solid var(--table-border);text-align:left;vertical-align:top;transition:border-color 0.3s ease;
          /* Text truncation for table cells */
          white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:150px}
    
    /* Mobile responsive table */
    @media (max-width: 768px) {
      th,td{padding:16px 12px;font-size:12px;max-width:120px}
      table{font-size:12px}
    }
    
    @media (max-width: 480px) {
      th,td{padding:14px 10px;max-width:100px;font-size:11px}
      /* Hide some columns on very small screens */
      th:nth-child(4), td:nth-child(4),
      th:nth-child(6), td:nth-child(6) {display:none}
    }

    /* hide the bottom border on the final row */
    tbody tr:last-child td{ border-bottom: 0; }
    #histBody td {padding:20px;}

    /* Mobile responsive history body */
    @media (max-width: 768px) {
      #histBody td{padding:20px 12px}
    }
    
    @media (max-width: 480px) {
      #histBody td{padding:18px 10px}
    }

    #histTable th, #histTable td {text-align:center;}
    #histHead th {
      text-align:center;
      padding: 16px 14px;
      font-weight: 700;
      font-size: 13px;
      letter-spacing: 0.5px;
      text-transform: uppercase;
    }
    
    /* Mobile responsive history head */
    @media (max-width: 768px) {
      #histHead th{
        padding: 14px 12px;
        font-size: 12px;
      }
    }
    
    @media (max-width: 480px) {
      #histHead th{
        padding: 12px 10px;
        font-size: 11px;
      }
    }

    th{color:var(--muted);font-weight:600;user-select:none;transition:color 0.3s ease}
    th[data-key]{cursor:pointer}
    tbody tr:hover{background:var(--hover-bg)}

    .hint{color:var(--muted);font-size:12px;transition:color 0.3s ease;
          /* Text truncation for hints */
          white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

    /* Mobile responsive hint */
    @media (max-width: 768px) {
      .hint{font-size:11px}
    }

    /* highlight entire entry if any field changed */
    tbody tr.entry-changed{background:var(--changed-bg);}
    tbody tr.entry-changed:hover{background:var(--changed-hover);}

    /* Security alert styling */
    tbody tr.security-alert{background:var(--security-bg);}
    tbody tr.security-alert:hover{background:var(--security-hover);}

    /* Speed test styling */
    tbody tr.speed-test{background:var(--speedtest-bg);}
    tbody tr.speed-test:hover{background:var(--speedtest-hover);}

    .pill{display:inline-block;min-width:86px;text-align:center;border-radius:999px;padding:2px 8px;border:1px solid var(--line);background:var(--badge-bg);transition:all 0.3s ease;
          /* Text truncation for pills */
          white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:120px}

    /* Mobile responsive pill */
    @media (max-width: 768px) {
      .pill{min-width:60px;padding:2px 6px;font-size:11px;max-width:80px}
    }

    /* Mini map in the card */
    #miniMap{height:160px;border-radius:10px;overflow:hidden;outline:0px solid var(--line);background:var(--bg);transition:background 0.3s ease}
    @media (min-width: 900px){ #miniMap{height:200px;} }
    
    /* Mobile responsive mini map */
    @media (max-width: 768px) {
      #miniMap{height:120px}
    }
    
    @media (max-width: 480px) {
      #miniMap{height:100px}
    }

    /* small style for IPv6 line under IPv4 */
    .ip-multi { display:flex; flex-direction:column; gap:4px; }
    .ip-multi small { color: var(--muted); font-weight:500; transition:color 0.3s ease;
                      /* Text truncation for IPv6 */
                      white-space:nowrap;overflow:hidden;text-overflow:ellipsis }

    #moreBtn{
      margin: 16px auto 24px; 
      width: auto; 
      padding: 12px 20px; 
      border-radius: 12px; 
      background: var(--button-bg); 
      color: var(--text); 
      border: 1px solid var(--line); 
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 600;
      font-size: 13px;
      display: block;
      text-align: center;
    }
    #moreBtn:hover{
      background: var(--button-hover);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    
    /* Mobile responsive more button */
    @media (max-width: 768px) {
      #moreBtn{
        margin: 12px auto 16px;
        padding: 10px 16px;
        font-size: 12px;
        width: auto;
        display: block;
      }
    }

    button{
      background: var(--button-bg);
      color: var(--text);
      border: 1px solid var(--line);
      padding: 10px 16px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 500;
      font-size: 13px;
    }
    button:hover{
      background: var(--button-hover);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    /* Mobile responsive button */
    @media (max-width: 768px) {
      button{
        padding: 8px 12px;
        font-size: 12px;
      }
    }

    /* Version footer */
    .version-footer{
      text-align:center;
      padding:20px 16px;
      color:var(--muted);
      font-size:11px;
      border-top:1px solid var(--line);
      margin-top:20px;
      background:var(--card-bg);
      backdrop-filter:blur(8px) saturate(120%);
    }
    
    /* Mobile responsive version footer */
    @media (max-width: 768px) {
      .version-footer{padding:15px 12px;font-size:10px;margin-top:15px}
    }

    .version-memo{
      margin-top:8px;
      font-style:italic;
      opacity:0.7;
    }

  </style>
</head>
<body>
  <div id="mapbg"></div>
  <div id="shade"></div>

  <main>

    <section class="card" id="live">
      <div class="row" style="justify-content:space-between">
        <div class="row">
          <span id="flag" class="flag"></span>
          <div>
            <div id="greeting" style="font-weight:700;font-size:16px">Loading…</div>
            <div id="greetSub" class="hint"></div>
          </div>
        </div>
        <div class="row" id="changeBadges" style="gap:6px">
          <div class="badge-container collapsed" id="badgeContainer">
            <!-- Theme toggle moved to settings -->
          </div>
        </div>
      </div>

      <div class="grid" style="margin-top:-2px">
        <div class="kv"><div class="k">Country</div><div class="v" id="country">—</div></div>
        <div class="kv"><div class="k">Region / City</div><div class="v" id="place">—</div></div>
        <div class="kv"><div class="k">ISP</div><div class="v" id="isp">—</div></div>
        <div class="kv"><div class="k">ASN</div><div class="v" id="asn">—</div></div>
        <div class="kv"><div class="k">IP Address</div><div class="v" id="ip">—</div></div>
        <div class="kv"><div class="k">Timezone</div><div class="v" id="tz">—</div></div>
        <div class="kv"><div class="k">User Agent</div><div class="v" id="ua">—</div></div>

        <!-- mini map stays as-is -->
        <div class="kv">
          <div id="miniMap"></div>
        </div>
      </div>
    </section>

    <!-- Speed Test Section - Button-based design -->
    <section class="card">
      <!-- Progress bars for each test phase -->
      <div style="margin:10px;margin-bottom:16px;">
        <div style="display:flex;gap:8px;margin-bottom:8px;">
          <div style="flex:1;">
            <div style="font-size:11px;color:var(--muted);margin-bottom:2px;">Ping</div>
            <div style="height:4px;background:var(--line);border-radius:2px;overflow:hidden;">
              <div id="pingProgress" style="height:100%;background:#f5b64d;border-radius:2px;width:0%;transition:width 0.3s ease;"></div>
            </div>
          </div>
          <div style="flex:1;">
            <div style="font-size:11px;color:var(--muted);margin-bottom:2px;">Download</div>
            <div style="height:4px;background:var(--line);border-radius:2px;overflow:hidden;">
              <div id="downloadProgress" style="height:100%;background:#35c48b;border-radius:2px;width:0%;transition:width 0.3s ease;"></div>
            </div>
          </div>
          <div style="flex:1;">
            <div style="font-size:11px;color:var(--muted);margin-bottom:2px;">Upload</div>
            <div style="height:4px;background:var(--line);border-radius:2px;overflow:hidden;">
              <div id="uploadProgress" style="height:100%;background:#7aa2ff;border-radius:2px;width:0%;transition:width 0.3s ease;"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="grid" style="margin-top:-2px">
        <div class="kv">
          <div class="k">Download</div>
          <div class="v" id="downloadSpeed">—</div>
          <small id="downloadRange" style="color:var(--muted);font-size:10px;display:block;margin-top:2px;"></small>
        </div>
        <div class="kv">
          <div class="k">Upload</div>
          <div class="v" id="uploadSpeed">—</div>
          <small id="uploadRange" style="color:var(--muted);font-size:10px;display:block;margin-top:2px;"></small>
        </div>
        <div class="kv">
          <div class="k">Ping</div>
          <div class="v" id="pingTime">—</div>
        </div>
        
        <!-- Big interactive status/start button -->
        <div class="kv" style="position:relative;overflow:hidden;cursor:pointer;" onclick="toggleSpeedTest()" id="speedTestButton">
          <!-- Progress background that fills the button -->
          <div id="buttonProgress" style="position:absolute;top:0;left:0;height:100%;background:linear-gradient(90deg,var(--accent)20,transparent);width:0%;transition:width 0.3s ease;border-radius:10px;"></div>
          
          <div style="position:relative;z-index:1;">
            <div class="k">Speed Test</div>
            <div class="v" id="speedStatus" style="font-size:14px;font-weight:700;">Start Test</div>
          </div>
        </div>
      </div>
    </section>

    <section class="card">
      <div style="overflow:auto">
        <table id="histTable">
          <thead>
            <tr id="histHead">
              <th data-key="date" data-label="When">When</th>
              <th data-key="ip" data-label="IP">IP</th>
              <th data-key="country" data-label="Country">Country</th>
              <th data-key="city" data-label="City">City</th>
              <th data-key="isp" data-label="ISP">ISP</th>
              <th data-key="asn" data-label="ASN">ASN</th>
              <th data-key="changed" data-label="Changed">Changed</th>
              <th data-key="speed" data-label="Speed">Speed</th>
            </tr>
          </thead>
          <tbody id="histBody">
            <tr><td colspan="8" class="hint">No entries yet.</td></tr>
          </tbody>
        </table>
      </div>
    </section>
    <button id="moreBtn" title="Load more rows">Show more</button>
  </main>

  <!-- Version Footer -->
  <div class="version-footer">
    <div>IPoint v2.7.0 - Customizable Dashboard & Themes</div>
    <div class="version-memo">
      <!-- AI Memo: Added drag-and-drop widgets, custom themes, and settings popup -->
      <!-- Last updated: Advanced UI/UX with customization options -->
    </div>
    <div style="margin-top: 8px;">
      <button onclick="openSettings()" style="background: var(--button-bg); border: 1px solid var(--line); border-radius: 8px; padding: 6px 12px; color: var(--text); font-size: 11px; cursor: pointer; transition: all 0.2s ease;">
        ⚙️ Settings
      </button>
    </div>
  </div>

  <!-- Settings Popup -->
  <div id="settingsPopup" class="settings-popup">
    <div class="settings-content">
      <div class="settings-header">
        <div class="settings-title">Settings</div>
        <button class="settings-close" onclick="closeSettings()">×</button>
      </div>
      
      <div class="settings-section">
        <div class="settings-section-title">Theme</div>
        <div class="settings-group">
          <div class="settings-row">
            <div class="settings-label">Theme Mode</div>
            <select id="themeSelect" class="settings-input" onchange="changeThemeMode(this.value)">
              <option value="dark">Dark</option>
              <option value="light">Light</option>
              <option value="oled">OLED Black</option>
            </select>
          </div>
          <div class="settings-row">
            <div class="settings-label">Custom Accent Color</div>
            <input type="color" id="accentColor" class="color-picker" value="#7aa2ff" onchange="updateAccentColor(this.value)">
          </div>
          <div class="theme-preview" id="themePreview"></div>
        </div>
      </div>
      
      <div class="settings-section">
        <div class="settings-section-title">Dashboard</div>
        <div class="settings-group">
          <div class="settings-row">
            <div class="settings-label">Enable Drag & Drop</div>
            <div class="settings-toggle" id="dragToggle" onclick="toggleDragDrop()"></div>
          </div>
          <div class="settings-row">
            <div class="settings-label">Reset Widget Order</div>
            <button class="settings-button" onclick="resetWidgetOrder()">Reset</button>
          </div>
        </div>
      </div>
      
      <div class="settings-section">
        <div class="settings-section-title">Data</div>
        <div class="settings-group">
          <div class="settings-row">
            <div class="settings-label">Export Settings</div>
            <button class="settings-button" onclick="exportSettings()">Export</button>
          </div>
          <div class="settings-row">
            <div class="settings-label">Import Settings</div>
            <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importSettings(this)">
            <button class="settings-button" onclick="document.getElementById('importFile').click()">Import</button>
          </div>
        </div>
      </div>
      
      <div class="settings-button-group">
        <button class="settings-button primary" onclick="saveSettings()">Save Settings</button>
        <button class="settings-button" onclick="resetAllSettings()">Reset All</button>
      </div>
    </div>
  </div>

<script>
  const PRIMARY_API = 'https://ipwho.is/?lang=en';          // primary
  const FALLBACK_API = 'https://ipapi.co/json';              // fallback
  const IPV6_URL = 'https://api6.ipify.org?format=json';     // IPv6 check
  const KEY = 'ip_visit_history_v1';
  const THEME_KEY = 'ip_theme_preference';
  const SETTINGS_KEY = 'ip_settings_v1';
  const MAX_HISTORY_STORE = 500;   // keep latest 500 entries
  const HIST_PAGE_SIZE    = 20;    // rows per "page"
  let   histVisible       = HIST_PAGE_SIZE;
  let   SORT = { key: 'date', dir: 'desc' };

  // Customization variables
  let dragDropEnabled = false;
  let customAccentColor = '#7aa2ff';
  let currentTheme = 'dark';
  let widgetOrder = ['country', 'place', 'isp', 'asn', 'ip', 'tz', 'ua', 'map'];
  let draggedElement = null;
  let dragPlaceholder = null;

  // Kill-switch variables
  let killSwitchActive = false;
  let currentSessionIP = null;
  let killSwitchInterval = null;
  const KILL_SWITCH_INTERVAL = 5000; // 5 seconds

  // Speed test variables
  let speedTestActive = false;
  let speedTestAborted = false;
  let currentSpeedResults = null;

  // =========================
  // CUSTOMIZATION FUNCTIONS
  // =========================

  // Settings Management
  function loadSettings() {
    try {
      console.log('IPoint: Loading settings...');
      const saved = localStorage.getItem(SETTINGS_KEY);
      if (saved) {
        const settings = JSON.parse(saved);
        console.log('IPoint: Loaded settings:', settings);
        
        dragDropEnabled = settings.dragDropEnabled || false;
        customAccentColor = settings.customAccentColor || '#7aa2ff';
        currentTheme = settings.currentTheme || 'dark';
        widgetOrder = settings.widgetOrder || ['country', 'place', 'isp', 'asn', 'ip', 'tz', 'ua', 'map'];
        
        console.log('IPoint: Applying settings - dragDropEnabled:', dragDropEnabled, 'customAccentColor:', customAccentColor, 'currentTheme:', currentTheme);
        
        // Apply loaded settings - with safety checks
        try {
          updateDragDropUI();
          reorderWidgets(); // Apply saved widget order on load
          console.log('IPoint: Drag drop UI updated');
        } catch (e) {
          console.warn('Failed to update drag drop UI:', e);
        }
        
        try {
          updateAccentColor(customAccentColor);
          console.log('IPoint: Accent color updated');
        } catch (e) {
          console.warn('Failed to update accent color:', e);
        }
        
        try {
          setTheme(currentTheme);
          console.log('IPoint: Theme updated');
        } catch (e) {
          console.warn('Failed to set theme:', e);
        }
        
        try {
          reorderWidgets();
          console.log('IPoint: Widgets reordered');
        } catch (e) {
          console.warn('Failed to reorder widgets:', e);
        }
      } else {
        console.log('IPoint: No saved settings found');
      }
    } catch (e) {
      console.warn('Failed to load settings:', e);
    }
  }

  function saveSettings() {
    const settings = {
      dragDropEnabled,
      customAccentColor,
      currentTheme,
      widgetOrder,
      version: '2.7.0'
    };
    localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
    closeSettings();
  }

  function exportSettings() {
    const settings = {
      dragDropEnabled,
      customAccentColor,
      currentTheme,
      widgetOrder,
      version: '2.7.0',
      exportDate: new Date().toISOString()
    };
    
    const blob = new Blob([JSON.stringify(settings, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'ipoint-settings.json';
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      URL.revokeObjectURL(url);
      a.remove();
    }, 0);
  }

  function importSettings(input) {
    const file = input.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
      try {
        const settings = JSON.parse(e.target.result);
        
        if (settings.version && settings.version.startsWith('2.7')) {
          dragDropEnabled = settings.dragDropEnabled || false;
          customAccentColor = settings.customAccentColor || '#7aa2ff';
          currentTheme = settings.currentTheme || 'dark';
          widgetOrder = settings.widgetOrder || ['country', 'place', 'isp', 'asn', 'ip', 'tz', 'ua', 'map'];
          
          // Apply imported settings
          updateDragDropUI();
          updateAccentColor(customAccentColor);
          setTheme(currentTheme);
          reorderWidgets();
          
          alert('Settings imported successfully!');
        } else {
          alert('Invalid settings file format.');
        }
      } catch (e) {
        alert('Failed to import settings: ' + e.message);
      }
    };
    reader.readAsText(file);
  }

  // Settings Popup Functions
  function openSettings() {
    document.getElementById('settingsPopup').classList.add('visible');
    loadSettingsToUI();
  }

  function closeSettings() {
    document.getElementById('settingsPopup').classList.remove('visible');
  }

  function loadSettingsToUI() {
    document.getElementById('themeSelect').value = currentTheme;
    document.getElementById('accentColor').value = customAccentColor;
    document.getElementById('dragToggle').classList.toggle('active', dragDropEnabled);
    updateThemePreview();
  }

  function changeThemeMode(theme) {
    currentTheme = theme;
    setTheme(theme);
    updateThemePreview();
  }

  function updateAccentColor(color) {
    customAccentColor = color;
    
    // Convert hex to HSL for tinting
    const hsl = hexToHsl(color);
    
    // Update CSS custom properties
    const root = document.documentElement;
    root.style.setProperty('--accent', color);
    root.style.setProperty('--tint-hue', hsl.h);
    root.style.setProperty('--tint-saturation', hsl.s + '%');
    root.style.setProperty('--tint-lightness', hsl.l + '%');
    
    // Update theme preview
    updateThemePreview();
  }

  function hexToHsl(hex) {
    // Remove # if present
    hex = hex.replace('#', '');
    
    // Parse hex values
    const r = parseInt(hex.substr(0, 2), 16) / 255;
    const g = parseInt(hex.substr(2, 2), 16) / 255;
    const b = parseInt(hex.substr(4, 2), 16) / 255;
    
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    
    if (max === min) {
      h = s = 0; // achromatic
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    
    return {
      h: Math.round(h * 360),
      s: Math.round(s * 100),
      l: Math.round(l * 100)
    };
  }

  function updateThemePreview() {
    const preview = document.getElementById('themePreview');
    if (preview) {
      preview.style.setProperty('--accent', customAccentColor);
    }
  }

  function toggleDragDrop() {
    dragDropEnabled = !dragDropEnabled;
    document.getElementById('dragToggle').classList.toggle('active', dragDropEnabled);
    updateDragDropUI();
  }

  function updateDragDropUI() {
    const grid = document.querySelector('.grid');
    if (!grid) {
      console.warn('Grid not found, skipping drag drop UI update');
      return;
    }
    
    if (dragDropEnabled) {
      grid.classList.add('draggable');
      attachDragDropListeners();
    } else {
      grid.classList.remove('draggable');
      removeDragDropListeners();
    }
  }

  // Drag and Drop Functions
  function attachDragDropListeners() {
    const grid = document.querySelector('.grid');
    if (!grid) return;

    const widgets = grid.querySelectorAll('.kv');
    widgets.forEach(widget => {
      widget.draggable = true;
      widget.addEventListener('dragstart', handleDragStart);
      widget.addEventListener('dragend', handleDragEnd);
      widget.addEventListener('dragover', handleDragOver);
      widget.addEventListener('drop', handleDrop);
      
      // Add mobile touch support
      widget.addEventListener('touchstart', handleTouchStart, { passive: false });
      widget.addEventListener('touchmove', handleTouchMove, { passive: false });
      widget.addEventListener('touchend', handleTouchEnd, { passive: false });
    });
  }

  function removeDragDropListeners() {
    const grid = document.querySelector('.grid');
    if (!grid) return;

    const widgets = grid.querySelectorAll('.kv');
    widgets.forEach(widget => {
      widget.draggable = false;
      widget.removeEventListener('dragstart', handleDragStart);
      widget.removeEventListener('dragend', handleDragEnd);
      widget.removeEventListener('dragover', handleDragOver);
      widget.removeEventListener('drop', handleDrop);
      
      // Remove mobile touch support
      widget.removeEventListener('touchstart', handleTouchStart);
      widget.removeEventListener('touchmove', handleTouchMove);
      widget.removeEventListener('touchend', handleTouchEnd);
    });
  }

  function handleDragStart(e) {
    if (!dragDropEnabled) return;
    
    draggedElement = e.target;
    draggedElement.classList.add('dragging');
    
    // Create placeholder
    dragPlaceholder = document.createElement('div');
    dragPlaceholder.className = 'kv drag-placeholder';
    dragPlaceholder.style.height = draggedElement.offsetHeight + 'px';
    
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', draggedElement.outerHTML);
  }

  function handleDragEnd(e) {
    if (!dragDropEnabled) return;
    
    draggedElement.classList.remove('dragging');
    
    if (dragPlaceholder && dragPlaceholder.parentNode) {
      dragPlaceholder.parentNode.removeChild(dragPlaceholder);
    }
    
    draggedElement = null;
    dragPlaceholder = null;
  }

  function handleDragOver(e) {
    if (!dragDropEnabled) return;
    
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    
    const target = e.target.closest('.kv');
    if (target && target !== draggedElement) {
      target.classList.add('drag-over');
    }
  }

  function handleDrop(e) {
    if (!dragDropEnabled) return;
    
    e.preventDefault();
    
    const target = e.target.closest('.kv');
    if (target && target !== draggedElement) {
      target.classList.remove('drag-over');
      
      // Swap elements
      const grid = target.parentNode;
      const draggedIndex = Array.from(grid.children).indexOf(draggedElement);
      const targetIndex = Array.from(grid.children).indexOf(target);
      
      if (draggedIndex < targetIndex) {
        grid.insertBefore(draggedElement, target.nextSibling);
      } else {
        grid.insertBefore(draggedElement, target);
      }
      
      // Update widget order
      updateWidgetOrder();
    }
  }

  function updateWidgetOrder() {
    const grid = document.querySelector('.grid');
    if (!grid) return;
    
    const widgets = Array.from(grid.children);
    widgetOrder = widgets.map(widget => {
      const keyElement = widget.querySelector('.k');
      if (keyElement) {
        const text = keyElement.textContent.toLowerCase();
        if (text.includes('country')) return 'country';
        if (text.includes('region') || text.includes('city')) return 'place';
        if (text.includes('isp')) return 'isp';
        if (text.includes('asn')) return 'asn';
        if (text.includes('ip')) return 'ip';
        if (text.includes('timezone')) return 'tz';
        if (text.includes('user agent')) return 'ua';
        if (widget.querySelector('#miniMap')) return 'map';
      }
      return 'unknown';
    }).filter(Boolean);
    
    // Save widget order immediately
    const settings = {
      dragDropEnabled,
      customAccentColor,
      currentTheme,
      widgetOrder,
      version: '2.7.0'
    };
    localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
  }

  function reorderWidgets() {
    const grid = document.querySelector('.grid');
    if (!grid) {
      console.warn('Grid not found, skipping widget reorder');
      return;
    }
    
    const widgets = Array.from(grid.children);
    const orderedWidgets = [];
    
    // Create a map of widgets by type
    const widgetMap = {};
    widgets.forEach(widget => {
      const keyElement = widget.querySelector('.k');
      if (keyElement) {
        const text = keyElement.textContent.toLowerCase();
        if (text.includes('country')) widgetMap.country = widget;
        else if (text.includes('region') || text.includes('city')) widgetMap.place = widget;
        else if (text.includes('isp')) widgetMap.isp = widget;
        else if (text.includes('asn')) widgetMap.asn = widget;
        else if (text.includes('ip')) widgetMap.ip = widget;
        else if (text.includes('timezone')) widgetMap.tz = widget;
        else if (text.includes('user agent')) widgetMap.ua = widget;
        else if (widget.querySelector('#miniMap')) widgetMap.map = widget;
      }
    });
    
    // Reorder based on saved order
    widgetOrder.forEach(type => {
      if (widgetMap[type]) {
        orderedWidgets.push(widgetMap[type]);
      }
    });
    
    // Add any remaining widgets
    widgets.forEach(widget => {
      if (!orderedWidgets.includes(widget)) {
        orderedWidgets.push(widget);
      }
    });
    
    // Update DOM
    orderedWidgets.forEach(widget => {
      grid.appendChild(widget);
    });
  }

  function resetWidgetOrder() {
    widgetOrder = ['country', 'place', 'isp', 'asn', 'ip', 'tz', 'ua', 'map'];
    reorderWidgets();
  }

  function resetAllSettings() {
    if (confirm('Reset all settings to default? This will clear your customizations.')) {
      localStorage.removeItem(SETTINGS_KEY);
      dragDropEnabled = false;
      customAccentColor = '#7aa2ff';
      currentTheme = 'dark';
      widgetOrder = ['country', 'place', 'isp', 'asn', 'ip', 'tz', 'ua', 'map'];
      
      // Reset UI
      updateDragDropUI();
      updateAccentColor(customAccentColor);
      setTheme(currentTheme);
      reorderWidgets();
      loadSettingsToUI();
    }
  }

  // Mobile Touch Support for Drag and Drop
  let touchStartX = 0;
  let touchStartY = 0;
  let touchMoved = false;
  let touchElement = null;

  function handleTouchStart(e) {
    if (!dragDropEnabled) return;
    
    const touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
    touchMoved = false;
    touchElement = e.target.closest('.kv');
    
    if (touchElement) {
      e.preventDefault();
    }
  }

  function handleTouchMove(e) {
    if (!dragDropEnabled || !touchElement) return;
    
    const touch = e.touches[0];
    const deltaX = Math.abs(touch.clientX - touchStartX);
    const deltaY = Math.abs(touch.clientY - touchStartY);
    
    // If moved more than 10px, start drag
    if (deltaX > 10 || deltaY > 10) {
      if (!touchMoved) {
        touchMoved = true;
        touchElement.classList.add('dragging');
        
        // Create placeholder
        dragPlaceholder = document.createElement('div');
        dragPlaceholder.className = 'kv drag-placeholder';
        dragPlaceholder.style.height = touchElement.offsetHeight + 'px';
        touchElement.parentNode.insertBefore(dragPlaceholder, touchElement.nextSibling);
        
        draggedElement = touchElement;
      }
      
      e.preventDefault();
    }
  }

  function handleTouchEnd(e) {
    if (!dragDropEnabled || !touchElement) return;
    
    if (touchMoved && draggedElement) {
      // Find drop target
      const touch = e.changedTouches[0];
      const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
      const target = elementBelow ? elementBelow.closest('.kv') : null;
      
      if (target && target !== draggedElement) {
        // Swap elements
        const grid = target.parentNode;
        const draggedIndex = Array.from(grid.children).indexOf(draggedElement);
        const targetIndex = Array.from(grid.children).indexOf(target);
        
        if (draggedIndex < targetIndex) {
          grid.insertBefore(draggedElement, target.nextSibling);
        } else {
          grid.insertBefore(draggedElement, target);
        }
        
        // Update widget order
        updateWidgetOrder();
      }
      
      // Clean up
      draggedElement.classList.remove('dragging');
      if (dragPlaceholder && dragPlaceholder.parentNode) {
        dragPlaceholder.parentNode.removeChild(dragPlaceholder);
      }
      draggedElement = null;
      dragPlaceholder = null;
    }
    
    touchElement = null;
    touchMoved = false;
  }

  const $ = (id) => document.getElementById(id);
  const fmt = (d) => new Intl.DateTimeFormat(undefined,{year:'numeric',month:'short',day:'2-digit',hour:'2-digit',minute:'2-digit',second:'2-digit'}).format(d);
  const fmtDate = (d) => new Intl.DateTimeFormat(undefined,{year:'numeric',month:'short',day:'2-digit'}).format(d);
  const fmtTime = (d) => new Intl.DateTimeFormat(undefined,{hour:'2-digit',minute:'2-digit',second:'2-digit'}).format(d);
  
  // Calculate relative time (x minutes/hours ago)
  function getRelativeTime(timestamp) {
    const now = Date.now();
    const diff = now - timestamp;
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    const weeks = Math.floor(days / 7);
    const months = Math.floor(days / 30);
    const years = Math.floor(days / 365);
    
    if (years > 0) {
      return years === 1 ? '1 year ago' : `${years} years ago`;
    } else if (months > 0) {
      return months === 1 ? '1 month ago' : `${months} months ago`;
    } else if (weeks > 0) {
      return weeks === 1 ? '1 week ago' : `${weeks} weeks ago`;
    } else if (days > 0) {
      return days === 1 ? '1 day ago' : `${days} days ago`;
    } else if (hours > 0) {
      return hours === 1 ? '1 hour ago' : `${hours} hours ago`;
    } else if (minutes > 0) {
      return minutes === 1 ? '1 minute ago' : `${minutes} minutes ago`;
    } else if (seconds > 30) {
      return `${seconds} seconds ago`;
    } else {
      return 'Just now';
    }
  }
  
  // Create and manage date popup
  let currentPopup = null;
  let popupTimeout = null;
  let currentMouseX = 0;
  let currentMouseY = 0;
  
  // Track mouse position
  document.addEventListener('mousemove', (e) => {
    currentMouseX = e.clientX;
    currentMouseY = e.clientY;
  });
  
  function createDatePopup(timestamp, targetElement, event) {
    // Remove any existing popup
    if (currentPopup) {
      currentPopup.remove();
      currentPopup = null;
    }
    
    // Create new popup
    const popup = document.createElement('div');
    popup.className = 'date-popup';
    
    const date = new Date(timestamp);
    const fullDate = new Intl.DateTimeFormat(undefined, {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    }).format(date);
    const fullTime = new Intl.DateTimeFormat(undefined, {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    }).format(date);
    
    popup.innerHTML = `
      <div class="date-popup-content">
        <div class="date-popup-time">${fullDate}</div>
        <div class="date-popup-ago">${fullTime}</div>
      </div>
    `;
    
    document.body.appendChild(popup);
    
    // Position popup at cursor, to the right
    const mouseX = event ? event.clientX : currentMouseX;
    const mouseY = event ? event.clientY : currentMouseY;
    const offset = 15; // Distance from cursor
    
    popup.style.left = (mouseX + offset) + 'px';
    popup.style.top = (mouseY - 10) + 'px';
    popup.style.transform = 'none';
    
    // Check if popup goes off screen and adjust
    setTimeout(() => {
      const popupRect = popup.getBoundingClientRect();
      
      // Adjust horizontal position if it goes off screen
      if (popupRect.right > window.innerWidth) {
        popup.style.left = (mouseX - popupRect.width - offset) + 'px';
      } else if (popupRect.left < 0) {
        popup.style.left = '10px';
      }
      
      // Adjust vertical position if it goes off screen
      if (popupRect.top < 0) {
        popup.style.top = (mouseY + offset) + 'px';
      } else if (popupRect.bottom > window.innerHeight) {
        popup.style.top = (mouseY - popupRect.height - offset) + 'px';
      }
      
      // Show popup with animation
      popup.classList.add('visible');
    }, 10);
    
    currentPopup = popup;
  }
  
  function hidePopup() {
    if (currentPopup) {
      currentPopup.classList.remove('visible');
      setTimeout(() => {
        if (currentPopup) {
          currentPopup.remove();
          currentPopup = null;
        }
      }, 200);
    }
  }
  
  // Handle date cell interactions
  function attachDateListeners(td, timestamp) {
    // Desktop hover
    td.addEventListener('mouseenter', (e) => {
      clearTimeout(popupTimeout);
      createDatePopup(timestamp, td, e);
    });
    
    td.addEventListener('mouseleave', (e) => {
      popupTimeout = setTimeout(hidePopup, 100);
    });
    
    // Mobile touch
    let touchTimeout;
    td.addEventListener('click', (e) => {
      e.stopPropagation();
      clearTimeout(touchTimeout);
      
      if (currentPopup && currentPopup.targetElement === td) {
        hidePopup();
      } else {
        createDatePopup(timestamp, td, e);
        currentPopup.targetElement = td;
        
        // Auto-hide after 3 seconds on mobile
        touchTimeout = setTimeout(hidePopup, 3000);
      }
    });
  }

  // Text truncation helper function
  function truncateText(text, maxLength = 50) {
    if (!text) return '—';
    const str = String(text);
    return str.length > maxLength ? str.substring(0, maxLength) + '...' : str;
  }

  // Speed Test Implementation - Using working public endpoints
  class SpeedTest {
    constructor() {
      // Use actual working speed test endpoints
      this.downloadUrls = [
        'https://speed.cloudflare.com/__down?bytes=',
        'https://proof.ovh.net/files/'  // OVH speed test files
      ];
      this.uploadEndpoint = 'https://httpbin.org/post';
      this.abortController = null;
    }

    async measurePing() {
      updateSpeedStatus('Testing ping...');
      const pings = [];
      
      // Test ping to multiple reliable endpoints
      const endpoints = [
        'https://1.1.1.1/cdn-cgi/trace',
        'https://8.8.8.8/resolve',
        'https://www.google.com/generate_204'
      ];
      
      for (let i = 0; i < endpoints.length; i++) {
        if (speedTestAborted) return null;
        
        const progress = ((i + 1) / endpoints.length) * 100;
        document.getElementById('pingProgress').style.width = progress + '%';
        
        const start = performance.now();
        try {
          await fetch(endpoints[i] + '?t=' + Date.now(), { 
            mode: 'no-cors',
            cache: 'no-store',
            signal: this.abortController?.signal
          });
        } catch (error) {
          if (error.name === 'AbortError') return null;
        }
        const end = performance.now();
        pings.push(end - start);
        
        // Update display
        const currentAvg = pings.reduce((a, b) => a + b) / pings.length;
        document.getElementById('pingTime').textContent = Math.round(currentAvg) + ' ms';
        
        await new Promise(resolve => setTimeout(resolve, 200));
      }
      
      document.getElementById('pingProgress').style.width = '100%';
      return pings.reduce((a, b) => a + b) / pings.length;
    }

    async measureDownload() {
      updateSpeedStatus('Testing download...');
      
      try {
        // Use Cloudflare's speed test endpoint with large file
        const testSize = 1024 * 1024 * 200; // 200MB
        const response = await fetch(`https://speed.cloudflare.com/__down?bytes=${testSize}`, {
          cache: 'no-store',
          signal: this.abortController?.signal
        });
        
        if (!response.ok) throw new Error('Download endpoint unavailable');
        
        const reader = response.body.getReader();
        let downloadedBytes = 0;
        let speedReadings = [];
        const startTime = performance.now();
        let lastTime = startTime;
        let lastBytes = 0;
        const testDuration = 10000; // 10 seconds
        
        while (true) {
          const { done, value } = await reader.read();
          const currentTime = performance.now();
          
          if (done || currentTime - startTime > testDuration || speedTestAborted) {
            reader.cancel();
            break;
          }
          
          downloadedBytes += value?.length || 0;
          
          // Calculate speed every 500ms
          if (currentTime - lastTime > 500) {
            const timeDiff = (currentTime - lastTime) / 1000;
            const bytesDiff = downloadedBytes - lastBytes;
            const speedMbps = (bytesDiff * 8) / (timeDiff * 1024 * 1024);
            
            // Skip first 2 seconds for connection ramp-up
            if (currentTime - startTime > 2000) {
              speedReadings.push(speedMbps);
              
              // Update live display
              if (speedReadings.length > 0) {
                const high = Math.max(...speedReadings);
                const low = Math.min(...speedReadings);
                const avg = (high + low) / 2;
                
                document.getElementById('downloadSpeed').textContent = avg.toFixed(1) + ' Mbps';
                document.getElementById('downloadRange').textContent = `${low.toFixed(1)} - ${high.toFixed(1)} Mbps`;
              }
            }
            
            // Update progress
            const progress = Math.min(100, ((currentTime - startTime) / testDuration) * 100);
            document.getElementById('downloadProgress').style.width = progress + '%';
            
            lastTime = currentTime;
            lastBytes = downloadedBytes;
          }
        }
        
        document.getElementById('downloadProgress').style.width = '100%';
        
        if (speedReadings.length === 0) return { average: 0, high: 0, low: 0 };
        
        const high = Math.max(...speedReadings);
        const low = Math.min(...speedReadings);
        const average = (high + low) / 2;
        
        return { average, high, low };
        
      } catch (error) {
        console.warn('Download test failed:', error);
        return { average: 0, high: 0, low: 0 };
      }
    }

    async measureUpload() {
      updateSpeedStatus('Testing upload...');
      
      try {
        const chunkSize = 1024 * 1024 * 4; // 4MB chunks
        const totalChunks = 12; // 48MB total over ~10 seconds
        const startTime = performance.now();
        let speedReadings = [];
        
        for (let i = 0; i < totalChunks; i++) {
          if (speedTestAborted || performance.now() - startTime > 12000) break;
          
          // Generate test data
          const chunk = new Uint8Array(chunkSize);
          // Use a faster fill method
          const pattern = new Uint32Array(chunkSize / 4);
          for (let j = 0; j < pattern.length; j++) {
            pattern[j] = (i * 1000 + j) % 0xFFFFFFFF;
          }
          chunk.set(new Uint8Array(pattern.buffer));
          
          const chunkStart = performance.now();
          
          try {
            const response = await fetch('https://httpbin.org/post', {
              method: 'POST',
              body: chunk,
              cache: 'no-store',
              signal: this.abortController?.signal,
              headers: {
                'Content-Type': 'application/octet-stream'
              }
            });
            
            if (response.ok) {
              await response.text();
              
              const chunkEnd = performance.now();
              const chunkDuration = (chunkEnd - chunkStart) / 1000;
              const chunkSpeed = (chunkSize * 8) / (chunkDuration * 1024 * 1024);
              
              // Skip first 2 chunks for ramp-up
              if (i >= 2) {
                speedReadings.push(chunkSpeed);
                
                if (speedReadings.length > 0) {
                  const high = Math.max(...speedReadings);
                  const low = Math.min(...speedReadings);
                  const avg = (high + low) / 2;
                  
                  document.getElementById('uploadSpeed').textContent = avg.toFixed(1) + ' Mbps';
                  document.getElementById('uploadRange').textContent = `${low.toFixed(1)} - ${high.toFixed(1)} Mbps`;
                }
              }
              
              const progress = Math.min(100, ((performance.now() - startTime) / 10000) * 100);
              document.getElementById('uploadProgress').style.width = progress + '%';
            }
          } catch (error) {
            if (error.name === 'AbortError') break;
            console.warn('Upload chunk failed:', error);
          }
          
          // Small delay between chunks to avoid overwhelming the server
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        document.getElementById('uploadProgress').style.width = '100%';
        
        if (speedReadings.length === 0) return { average: 0, high: 0, low: 0 };
        
        const high = Math.max(...speedReadings);
        const low = Math.min(...speedReadings);
        const average = (high + low) / 2;
        
        return { average, high, low };
        
      } catch (error) {
        console.warn('Upload test failed:', error);
        return { average: 0, high: 0, low: 0 };
      }
    }

    abort() {
      if (this.abortController) {
        this.abortController.abort();
      }
    }
  }

  const speedTester = new SpeedTest();

  function updateSpeedDisplay(download, upload, ping) {
    if (download !== null) $('downloadSpeed').textContent = download.toFixed(1) + ' Mbps';
    if (upload !== null) $('uploadSpeed').textContent = upload.toFixed(1) + ' Mbps';
    if (ping !== null) $('pingTime').textContent = Math.round(ping) + ' ms';
  }

  function updateSpeedStatus(message) {
    $('speedStatus').textContent = message;
  }

  function updateButtonProgress(percent) {
    document.getElementById('buttonProgress').style.width = percent + '%';
  }

  function resetProgressBars() {
    document.getElementById('pingProgress').style.width = '0%';
    document.getElementById('downloadProgress').style.width = '0%';
    document.getElementById('uploadProgress').style.width = '0%';
    updateButtonProgress(0);
  }

  function toggleSpeedTest() {
    if (speedTestActive) {
      stopSpeedTest();
    } else {
      startSpeedTest();
    }
  }

  async function startSpeedTest() {
    if (speedTestActive) return;
    
    speedTestActive = true;
    speedTestAborted = false;
    currentSpeedResults = { download: null, upload: null, ping: null };
    
    // Update button appearance
    const button = $('speedTestButton');
    button.style.cursor = 'pointer';
    updateSpeedStatus('Testing...');
    
    // Reset displays and progress bars
    $('downloadSpeed').textContent = '—';
    $('uploadSpeed').textContent = '—';
    $('pingTime').textContent = '—';
    resetProgressBars();
    
    try {
      // Step 1: Ping test (2-3 seconds)
      updateSpeedStatus('Testing ping...');
      updateButtonProgress(10);
      
      const ping = await speedTester.measurePing();
      if (speedTestAborted) return;
      currentSpeedResults.ping = ping;
      
      // Step 2: Download test (10 seconds)
      updateSpeedStatus('Testing download...');
      updateButtonProgress(40);
      
      const download = await speedTester.measureDownload();
      if (speedTestAborted) return;
      currentSpeedResults.download = download;
      
      // Step 3: Upload test (10 seconds)
      updateSpeedStatus('Testing upload...');
      updateButtonProgress(70);
      
      const upload = await speedTester.measureUpload();
      if (speedTestAborted) return;
      currentSpeedResults.upload = upload;
      
      updateSpeedStatus('Test Complete');
      updateButtonProgress(100);
      
      // Save results
      if (currentSpeedResults.download !== null || currentSpeedResults.upload !== null) {
        saveSpeedTestResult();
      }
      
    } catch (error) {
      console.error('Speed test error:', error);
      updateSpeedStatus('Test Failed');
    } finally {
      // Reset UI after delay
      speedTestActive = false;
      
      setTimeout(() => {
        if (!speedTestActive) {
          updateSpeedStatus('Start Test');
          updateButtonProgress(0);
        }
      }, 3000);
    }
  }

  function stopSpeedTest() {
    if (!speedTestActive) return;
    
    speedTestAborted = true;
    speedTestActive = false;
    
    updateSpeedStatus('Test Stopped');
    resetProgressBars();
    
    setTimeout(() => {
      updateSpeedStatus('Start Test');
    }, 2000);
  }

  function saveSpeedTestResult() {
    // Get current IP data to associate with speed test
    const hist = getHistory();
    const lastEntry = hist[hist.length - 1];
    
    if (!lastEntry) return;
    
    // Create a speed test entry
    const speedEntry = {
      timestamp: Date.now(),
      ip: lastEntry.ip,
      country: lastEntry.country,
      country_code: lastEntry.country_code,
      city: lastEntry.city,
      region: lastEntry.region,
      connection: lastEntry.connection,
      timezone: lastEntry.timezone,
      speedTest: {
        download: currentSpeedResults.download ? currentSpeedResults.download.average : null,
        downloadHigh: currentSpeedResults.download ? currentSpeedResults.download.high : null,
        downloadLow: currentSpeedResults.download ? currentSpeedResults.download.low : null,
        upload: currentSpeedResults.upload ? currentSpeedResults.upload.average : null,
        uploadHigh: currentSpeedResults.upload ? currentSpeedResults.upload.high : null,
        uploadLow: currentSpeedResults.upload ? currentSpeedResults.upload.low : null,
        ping: currentSpeedResults.ping
      },
      isSpeedTest: true
    };
    
    appendHistory(speedEntry);
    renderHistory();
  }

  // Theme management
  function initTheme() {
    const savedTheme = localStorage.getItem(THEME_KEY);
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const theme = savedTheme || (prefersDark ? 'dark' : 'light');
    setTheme(theme);
  }

  function setTheme(theme) {
    currentTheme = theme;
    document.documentElement.setAttribute('data-theme', theme);
    localStorage.setItem(THEME_KEY, theme);
    updateThemeToggle(theme);
    
    // Update map tiles based on theme
    if (mapBg) {
      let tileLayer;
      if (theme === 'light') {
        tileLayer = 'https://cartodb-basemaps-a.global.ssl.fastly.net/light_nolabels/{z}/{x}/{y}{r}.png';
      } else if (theme === 'oled') {
        tileLayer = 'https://cartodb-basemaps-a.global.ssl.fastly.net/dark_nolabels/{z}/{x}/{y}{r}.png';
      } else {
        tileLayer = 'https://cartodb-basemaps-a.global.ssl.fastly.net/dark_nolabels/{z}/{x}/{y}{r}.png';
      }
      mapBg.eachLayer(layer => {
        if (layer._url) {
          layer.setUrl(tileLayer);
        }
      });
    }
    
    if (mini) {
      let tileLayer;
      if (theme === 'light') {
        tileLayer = 'https://cartodb-basemaps-a.global.ssl.fastly.net/light_nolabels/{z}/{x}/{y}{r}.png';
      } else if (theme === 'oled') {
        tileLayer = 'https://cartodb-basemaps-a.global.ssl.fastly.net/dark_nolabels/{z}/{x}/{y}{r}.png';
      } else {
        tileLayer = 'https://cartodb-basemaps-a.global.ssl.fastly.net/dark_nolabels/{z}/{x}/{y}{r}.png';
      }
      mini.eachLayer(layer => {
        if (layer._url) {
          layer.setUrl(tileLayer);
        }
      });
    }
  }

  function updateThemeToggle(theme) {
    const icon = $('themeIcon');
    const text = $('themeText');
    if (icon && text) {
      if (theme === 'light') {
        icon.textContent = '🌙';
        text.textContent = 'Dark';
      } else if (theme === 'oled') {
        icon.textContent = '☀️';
        text.textContent = 'Light';
      } else {
        icon.textContent = '☀️';
        text.textContent = 'Light';
      }
    }
  }

  function toggleTheme() {
    const currentThemeAttr = document.documentElement.getAttribute('data-theme');
    let newTheme;
    if (currentThemeAttr === 'light') {
      newTheme = 'dark';
    } else if (currentThemeAttr === 'dark') {
      newTheme = 'oled';
    } else {
      newTheme = 'light';
    }
    setTheme(newTheme);
  }

  function getHistory(){ try { return JSON.parse(localStorage.getItem(KEY)) || []; } catch { return []; } }
  function setHistory(arr){ localStorage.setItem(KEY, JSON.stringify(arr)); }

  function renderFlag(cc){
    const el = $('flag'); el.innerHTML = '';
    if(!cc) return;
    const span = document.createElement('span');
    span.className = 'fi fi-' + cc.toLowerCase();
    span.style.width = '28px'; span.style.height='20px';
    el.appendChild(span);
  }

  function setFavicon(cc) {
    if (!cc) return;
    const base = cc.toUpperCase();
    [16,32,64].forEach(size => {
      let link = document.querySelector(`link[rel="icon"][sizes="${size}x${size}"]`);
      if (!link) {
        link = document.createElement('link');
        link.rel = 'icon';
        link.type = 'image/png';
        link.sizes = `${size}x${size}`;
        document.head.appendChild(link);
      }
      link.href = `https://flagsapi.com/${base}/flat/${size}.png`;
    });
  }

  function setKV(id, val){ 
    const element = $(id);
    const truncated = truncateText(val);
    element.textContent = truncated;
    // Add title attribute for full text on hover
    if (val && String(val).length > 50) {
      element.title = val;
    }
  }

  function deviceInfo(){
    const nav = navigator || {};
    const concurrency = nav.hardwareConcurrency ? `${nav.hardwareConcurrency} threads` : 'n/a';
    const mem = nav.deviceMemory ? `${nav.deviceMemory} GB` : 'n/a';
    const plat = nav.platform || 'n/a';
    return { ua: nav.userAgent || 'n/a', device: `${plat} • ${concurrency} • ${mem}` };
  }

  const VPN_KEYWORDS = ['vpn','mullvad','nord','express','pia','private internet access','surfshark','proton','hidemyass','hma','tunnelbear','windscribe','cyberghost','ivpn','perfect privacy','airvpn','vypr','hotspot shield','privatevpn','strongvpn','purevpn','hola vpn','colo','colocation','datacenter','datacentre','digitalocean','ovh','hetzner','leaseweb','vultr','linode','scaleway','contabo','aws','amazon','gcp','google cloud','azure'];
  function looksLikeVPN(connection){
    const hay = [connection?.isp, connection?.org, connection?.domain].filter(Boolean).join(' ').toLowerCase();
    return VPN_KEYWORDS.some(k => hay.includes(k));
  }

  // Badge container state
  let badgeContainerExpanded = false;
  let allBadges = [];
  let maxVisibleBadges = 3; // Maximum badges to show in collapsed state

  // Responsive badge handling
  function updateMaxVisibleBadges() {
    const width = window.innerWidth;
    if (width <= 480) {
      maxVisibleBadges = 1; // Very small screens
    } else if (width <= 768) {
      maxVisibleBadges = 2; // Mobile screens
    } else {
      maxVisibleBadges = 3; // Desktop screens
    }
    
    // Re-render badges if they exist
    if (allBadges.length > 0) {
      renderBadges();
    }
  }

  // Update on resize
  window.addEventListener('resize', updateMaxVisibleBadges);
  
  // Initialize on load
  updateMaxVisibleBadges();

  function diffBadges(prev, curr, isSecurityAlert = false){
    const container = $('badgeContainer');
    
    // Reset expansion state when new badges are created
    badgeContainerExpanded = false;
    
    if(!prev) {
      container.className = 'badge-container collapsed';
      allBadges = [];
      return;
    }
    
    const changed = [];
    if(prev.ip !== curr.ip) changed.push(['IP', 'bad']);
    if(prev.country_code !== curr.country_code) changed.push(['Country', 'warn']);
    if(prev.connection?.isp !== curr.connection?.isp) changed.push(['ISP', 'warn']);
    if(prev.connection?.asn !== curr.connection?.asn) changed.push(['ASN', 'warn']);
    
    // Add kill-switch badge if it's a security alert
    if (isSecurityAlert) {
      changed.unshift(['🚨 KILL-SWITCH', 'security']);
    }
    
    // Store all badges for responsive display
    allBadges = [];
    for(const [label, type] of changed){
      const text = `${label} ${type === 'security' ? 'TRIGGERED' : 'changed'}`;
      allBadges.push({ label, type, text });
    }
    
    if(changed.length === 0){
      allBadges.push({ label: 'No changes', type: 'good', text: 'No changes' });
    }
    
    // Render badges based on current state
    renderBadges();
  }

  function renderBadges() {
    const container = $('badgeContainer');
    
    // Clear ALL content
    container.innerHTML = '';
    
    // Determine how many badges to show
    const badgesToShow = badgeContainerExpanded ? allBadges : allBadges.slice(0, maxVisibleBadges);
    
    // Add visible badges
    badgesToShow.forEach(({ label, type, text }) => {
      const b = document.createElement('span');
      b.className = 'badge ' + type;
      b.textContent = truncateText(text, 15);
      b.title = text;
      container.appendChild(b);
    });
    
    // Add more/less toggle if needed
    if (allBadges.length > maxVisibleBadges) {
      const toggleBadge = document.createElement('span');
      toggleBadge.className = 'badge more';
      toggleBadge.textContent = badgeContainerExpanded ? 'Less' : `+${allBadges.length - maxVisibleBadges} more`;
      toggleBadge.onclick = toggleBadgeContainer;
      container.appendChild(toggleBadge);
    }
    
    // Update container class
    container.className = `badge-container ${badgeContainerExpanded ? 'expanded' : 'collapsed'}`;
  }

  function toggleBadgeContainer() {
    badgeContainerExpanded = !badgeContainerExpanded;
    renderBadges();
  }

  function appendHistory(entry){
    const hist = getHistory();
    hist.push(entry);
    if (hist.length > MAX_HISTORY_STORE) hist.splice(0, hist.length - MAX_HISTORY_STORE);
    setHistory(hist);
  }

  function setSort(key){
    if (SORT.key === key){ SORT.dir = SORT.dir === 'asc' ? 'desc' : 'asc'; }
    else { SORT.key = key; SORT.dir = (key === 'date') ? 'desc' : 'asc'; }
    histVisible = HIST_PAGE_SIZE;   // show first page again after resort
    renderHistory();
  }

  function renderSortIndicators(){
    const head = document.getElementById('histHead');
    [...head.querySelectorAll('th[data-key]')].forEach(th => {
      const key = th.getAttribute('data-key');
      const label = th.getAttribute('data-label') || th.textContent.replace(/[▲▼]\s*$/,'');
      const isActive = key === SORT.key;
      const arrow = isActive ? (SORT.dir === 'asc' ? ' ↑' : ' ↓') : '';
      th.textContent = label + arrow;
    });
  }

  function renderHistory(reset=false){
    if (reset) histVisible = HIST_PAGE_SIZE;

    const body = $('histBody');
    const hist = getHistory();
    body.innerHTML = '';

    if(hist.length === 0){
      const tr = document.createElement('tr'); const td = document.createElement('td');
      td.colSpan = 8; td.className = 'hint'; td.textContent = 'No entries yet.';
      tr.appendChild(td); body.appendChild(tr); renderSortIndicators();
      const moreBtn = $('moreBtn'); if (moreBtn) moreBtn.style.display = 'none';
      return;
    }

    // Compute changed flags in chronological order
    let last = null;
    const enriched = hist.map(h => {
      const changed = {
        ip: !!(last && last.ip !== h.ip),
        country: !!(last && last.country_code !== h.country_code),
        isp: !!(last && (last.connection?.isp || '') !== (h.connection?.isp || '')),
        asn: !!(last && (last.connection?.asn || '') !== (h.connection?.asn || ''))
      };
      const anyChanged = Object.values(changed).some(Boolean); 
      const isSecurityAlert = h.securityAlert || false;
      const isSpeedTest = h.isSpeedTest || false;
      
      let speedDisplay = '—';
      if (h.speedTest) {
        const down = h.speedTest.download ? `${h.speedTest.download.toFixed(1)}↓` : '';
        const up = h.speedTest.upload ? `${h.speedTest.upload.toFixed(1)}↑` : '';
        const ping = h.speedTest.ping ? `${Math.round(h.speedTest.ping)}ms` : '';
        speedDisplay = [down, up, ping].filter(Boolean).join(' ');
      }
      
      last = h;
      return {
        date: h.timestamp, ip: h.ip || '',
        country: (h.country || '') + (h.country_code ? ` (${h.country_code})` : ''),
        city: h.city || '', isp: (h.connection && h.connection.isp) || '',
        asn: (h.connection && h.connection.asn) || '', 
        changed: isSecurityAlert ? 'SECURITY ALERT' : (isSpeedTest ? 'SPEED TEST' : (anyChanged ? 'Yes' : 'No')),
        speed: speedDisplay,
        changedFlags: changed,
        securityAlert: isSecurityAlert,
        speedTest: isSpeedTest
      };
    });

    // Sort for display
    const rows = enriched.slice(); const dir = (SORT.dir === 'asc') ? 1 : -1;
    rows.sort((a,b) => {
      const key = SORT.key; let va = a[key], vb = b[key];
      if (key === 'date') return (a.date - b.date) * dir;
      if (key === 'asn'){
        const na = parseInt(String(a.asn).replace(/[^\d]/g,''),10);
        const nb = parseInt(String(b.asn).replace(/[^\d]/g,''),10);
        if (Number.isFinite(na) && Number.isFinite(nb)) return (na === nb ? 0 : (na < nb ? -1 : 1)) * dir;
      }
      va = (va ?? '').toString(); vb = (vb ?? '').toString();
      return va.localeCompare(vb, undefined, { numeric:true, sensitivity:'base' }) * dir;
    });

    // Slice to visible window
    const total = rows.length;
    const visibleRows = rows.slice(0, Math.min(histVisible, total));

    visibleRows.forEach(h => {
      const tr = document.createElement('tr');
      if (h.securityAlert) {
        tr.classList.add('security-alert');
      } else if (h.speedTest) {
        tr.classList.add('speed-test');
      } else if (h.changed === 'Yes') {
        tr.classList.add('entry-changed');
      }
      
      // Use relative time instead of date
      const relativeTime = getRelativeTime(h.date);
      const ipText = h.ip || '—';
      const countryText = h.country || '—';
      const cityText = h.city || '—';
      const ispText = h.isp || '—';
      const asnText = h.asn || '—';
      const changedText = h.changed;
      const speedText = h.speed || '—';
      
      // Create date cell with special class
      const dateCell = document.createElement('td');
      dateCell.className = 'date-cell';
      dateCell.textContent = relativeTime;
      dateCell.title = ''; // Remove default title
      
      // Attach date popup listeners
      attachDateListeners(dateCell, h.date);
      
      // Add the cell to the row first
      tr.appendChild(dateCell);
      
      // Add remaining cells
      const remainingCells = `
        <td ${h.changedFlags.ip ? 'class="changed"' : ''} title="${ipText}">${truncateText(ipText, 15)}</td>
        <td ${h.changedFlags.country ? 'class="changed"' : ''} title="${countryText}">${truncateText(countryText, 15)}</td>
        <td title="${cityText}">${truncateText(cityText, 12)}</td>
        <td ${h.changedFlags.isp ? 'class="changed"' : ''} title="${ispText}">${truncateText(ispText, 15)}</td>
        <td ${h.changedFlags.asn ? 'class="changed"' : ''} title="${asnText}">${truncateText(asnText, 10)}</td>
        <td style="${h.securityAlert ? 'color: #ef6a6a; font-weight: 600;' : (h.speedTest ? 'color: #7aa2ff; font-weight: 600;' : '')}" title="${changedText}">${truncateText(changedText, 12)}</td>
        <td title="${speedText}">${truncateText(speedText, 15)}</td>
      `;
      
      // Create temp element to parse HTML and append children properly
      const temp = document.createElement('tr');
      temp.innerHTML = remainingCells;
      while (temp.firstChild) {
        tr.appendChild(temp.firstChild);
      }
      
      body.appendChild(tr);
    });

    renderSortIndicators();

    // Update Show more button
    const moreBtn = $('moreBtn');
    if (moreBtn){
      const remaining = total - histVisible;
      if (remaining > 0){
        moreBtn.style.display = 'inline-block';
        moreBtn.textContent = `Show more (${Math.min(HIST_PAGE_SIZE, remaining)})`;
      } else {
        moreBtn.style.display = 'none';
      }
    }
  }

  $('moreBtn')?.addEventListener('click', () => {
    histVisible += HIST_PAGE_SIZE;
    renderHistory();
  });

  // Background map
  let mapBg;
  function initMapBg(lat, lon){
    try{
      const currentTheme = document.documentElement.getAttribute('data-theme');
      const tileLayer = currentTheme === 'light' 
        ? 'https://cartodb-basemaps-a.global.ssl.fastly.net/light_nolabels/{z}/{x}/{y}{r}.png'
        : 'https://cartodb-basemaps-a.global.ssl.fastly.net/dark_nolabels/{z}/{x}/{y}{r}.png';
      mapBg = L.map('mapbg',{zoomControl:false,attributionControl:false,dragging:false,scrollWheelZoom:false,doubleClickZoom:false,boxZoom:false,keyboard:false,tap:false,touchZoom:false});
      L.tileLayer(tileLayer,{maxZoom:18,minZoom:2}).addTo(mapBg);
      mapBg.setView([lat,lon],14);
      L.circleMarker([lat,lon],{radius:6,color:'#ffffff55',fillColor:'#ffffffaa',fillOpacity:0.6,weight:1}).addTo(mapBg);
    }catch(_){/* noop */}
  }

  // Mini map
  let mini;
  function initMiniMap(lat, lon){
    try{
      const currentTheme = document.documentElement.getAttribute('data-theme');
      const tileLayer = currentTheme === 'light' 
        ? 'https://cartodb-basemaps-a.global.ssl.fastly.net/light_nolabels/{z}/{x}/{y}{r}.png'
        : 'https://cartodb-basemaps-a.global.ssl.fastly.net/dark_nolabels/{z}/{x}/{y}{r}.png';
      mini = L.map('miniMap',{zoomControl:false,attributionControl:false,dragging:false,scrollWheelZoom:false,doubleClickZoom:false,boxZoom:false,keyboard:false,tap:false,touchZoom:false});
      L.tileLayer(tileLayer,{maxZoom:19,minZoom:2}).addTo(mini);
      mini.setView([lat,lon],16); // ultra zoom
      L.circleMarker([lat,lon],{radius:5,color:'#ffffff80',fillColor:'#ffffffcc',fillOpacity:0.85,weight:1}).addTo(mini);
      setTimeout(()=>mini.invalidateSize(), 0);
    }catch(_){/* noop */}
  }

  /* =========================
     Greeting helpers (language + daypart)
     ========================= */
  const CC_TO_LANG = {
    US:'en', GB:'en', CA:'en', AU:'en', NZ:'en', IE:'en', SG:'en',
    DE:'de', AT:'de', CH:'de',
    FR:'fr', BE:'fr', LU:'fr',
    IT:'it', ES:'es', PT:'pt', BR:'pt', NL:'nl',
    SE:'sv', NO:'no', DK:'da', FI:'fi',
    PL:'pl', CZ:'cs', RO:'ro', HU:'hu',
    RU:'ru', UA:'uk', TR:'tr',
    JP:'ja', KR:'ko', CN:'zh', TW:'zh', HK:'zh',
    AE:'ar', SA:'ar', EG:'ar', MA:'ar',
    IN:'hi', ID:'id', TH:'th', VN:'vi'
  };

  const GREETINGS = {
    en:{
      morning:['Good morning', 'Morning!', 'Rise and shine!', 'Top of the morning!', 'Good day ahead!'],
      afternoon:['Good afternoon', 'Afternoon!', 'Hope you\'re having a great day!', 'Good day!'],
      evening:['Good evening', 'Evening!', 'Hope you had a wonderful day!', 'Good night ahead!'],
      night:['Good night', 'Sweet dreams!', 'Sleep well!', 'Have a peaceful night!']
    },
    de:{
      morning:['Guten Morgen', 'Moin!', 'Guten Tag', 'Hallo!', 'Schönen guten Morgen!'],
      afternoon:['Guten Tag', 'Hallo!', 'Guten Nachmittag', 'Schönen Tag noch!'],
      evening:['Guten Abend', 'Hallo!', 'Schönen Abend!', 'Gute Nacht!'],
      night:['Gute Nacht', 'Schlaf gut!', 'Träum schön!', 'Bis morgen!']
    },
    fr:{
      morning:['Bonjour', 'Salut!', 'Bonne journée!', 'Bon matin!'],
      afternoon:['Bonjour', 'Salut!', 'Bonne après-midi!', 'Bonne journée!'],
      evening:['Bonsoir', 'Salut!', 'Bonne soirée!', 'Bonne nuit!'],
      night:['Bonne nuit', 'Dors bien!', 'Fais de beaux rêves!', 'À demain!']
    },
    it:{
      morning:['Buongiorno', 'Ciao!', 'Buona giornata!', 'Buon mattino!'],
      afternoon:['Buongiorno', 'Ciao!', 'Buon pomeriggio!', 'Buona giornata!'],
      evening:['Buonasera', 'Ciao!', 'Buona serata!', 'Buona notte!'],
      night:['Buonanotte', 'Sogni d\'oro!', 'Dormi bene!', 'A domani!']
    },
    es:{
      morning:['Buenos días', '¡Hola!', '¡Buen día!', '¡Que tengas un buen día!'],
      afternoon:['Buenas tardes', '¡Hola!', '¡Buenas tardes!', '¡Que tengas una buena tarde!'],
      evening:['Buenas tardes', '¡Hola!', '¡Buenas noches!', '¡Que tengas una buena noche!'],
      night:['Buenas noches', '¡Que descanses!', '¡Dulces sueños!', '¡Hasta mañana!']
    },
    pt:{
      morning:['Bom dia', 'Olá!', 'Boa manhã!', 'Tenha um ótimo dia!'],
      afternoon:['Boa tarde', 'Olá!', 'Tenha uma boa tarde!', 'Bom dia!'],
      evening:['Boa noite', 'Olá!', 'Tenha uma boa noite!', 'Boa noite!'],
      night:['Boa noite', 'Durma bem!', 'Sonhos doces!', 'Até amanhã!']
    },
    nl:{
      morning:['Goedemorgen', 'Hallo!', 'Goede dag!', 'Fijne dag!'],
      afternoon:['Goedemiddag', 'Hallo!', 'Goede dag!', 'Fijne middag!'],
      evening:['Goedenavond', 'Hallo!', 'Goede avond!', 'Fijne avond!'],
      night:['Goedenacht', 'Slaap lekker!', 'Droom zacht!', 'Tot morgen!']
    },
    sv:{
      morning:['God morgon', 'Hej!', 'God dag!', 'Ha en fin dag!'],
      afternoon:['God eftermiddag', 'Hej!', 'God dag!', 'Ha en fin eftermiddag!'],
      evening:['God kväll', 'Hej!', 'Ha en fin kväll!', 'God natt!'],
      night:['God natt', 'Sov gott!', 'Dröm sött!', 'Vi ses imorgon!']
    },
    no:{
      morning:['God morgen', 'Hei!', 'God dag!', 'Ha en fin dag!'],
      afternoon:['God ettermiddag', 'Hei!', 'God dag!', 'Ha en fin ettermiddag!'],
      evening:['God kveld', 'Hei!', 'Ha en fin kveld!', 'God natt!'],
      night:['God natt', 'Sov godt!', 'Drøm søtt!', 'Vi sees i morgen!']
    },
    da:{
      morning:['Godmorgen', 'Hej!', 'God dag!', 'Ha\' en god dag!'],
      afternoon:['God eftermiddag', 'Hej!', 'God dag!', 'Ha\' en god eftermiddag!'],
      evening:['Godaften', 'Hej!', 'Ha\' en god aften!', 'Godnat!'],
      night:['Godnat', 'Sov godt!', 'Drøm sødt!', 'Vi ses i morgen!']
    },
    fi:{
      morning:['Hyvää huomenta', 'Hei!', 'Hyvää päivää!', 'Mukavaa päivää!'],
      afternoon:['Hyvää iltapäivää', 'Hei!', 'Hyvää päivää!', 'Mukavaa iltapäivää!'],
      evening:['Hyvää iltaa', 'Hei!', 'Mukavaa iltaa!', 'Hyvää yötä!'],
      night:['Hyvää yötä', 'Nuku hyvin!', 'Uni nukkuu!', 'Nähdään huomenna!']
    },
    pl:{
      morning:['Dzień dobry', 'Cześć!', 'Miłego dnia!', 'Dobrego ranka!'],
      afternoon:['Dzień dobry', 'Cześć!', 'Miłego popołudnia!', 'Miłego dnia!'],
      evening:['Dobry wieczór', 'Cześć!', 'Miłego wieczoru!', 'Dobranoc!'],
      night:['Dobranoc', 'Śpij dobrze!', 'Słodkich snów!', 'Do zobaczenia jutro!']
    },
    ru:{
      morning:['Доброе утро', 'Привет!', 'Хорошего дня!', 'Доброго утра!'],
      afternoon:['Добрый день', 'Привет!', 'Хорошего дня!', 'Доброго дня!'],
      evening:['Добрый вечер', 'Привет!', 'Хорошего вечера!', 'Спокойной ночи!'],
      night:['Спокойной ночи', 'Спокойного сна!', 'Сладких снов!', 'До завтра!']
    },
    tr:{
      morning:['Günaydın', 'Merhaba!', 'İyi günler!', 'Güzel bir gün!'],
      afternoon:['İyi günler', 'Merhaba!', 'İyi öğleden sonra!', 'Güzel bir gün!'],
      evening:['İyi akşamlar', 'Merhaba!', 'Güzel bir akşam!', 'İyi geceler!'],
      night:['İyi geceler', 'İyi uykular!', 'Tatlı rüyalar!', 'Yarın görüşürüz!']
    },
    ja:{
      morning:['おはようございます', 'おはよう!', '今日も一日お疲れ様!', '良い一日を!'],
      afternoon:['こんにちは', 'お疲れ様!', '良い午後を!', '今日もお疲れ様!'],
      evening:['こんばんは', 'お疲れ様!', '良い夜を!', 'おやすみなさい!'],
      night:['おやすみなさい', 'おやすみ!', '良い夢を!', 'また明日!']
    },
    zh:{
      morning:['早上好', '你好!', '新的一天快乐!', '祝你有美好的一天!'],
      afternoon:['下午好', '你好!', '下午愉快!', '祝你有美好的一天!'],
      evening:['晚上好', '你好!', '晚上愉快!', '晚安!'],
      night:['晚安', '睡个好觉!', '好梦!', '明天见!']
    },
    ar:{
      morning:['صباح الخير', 'مرحبا!', 'صباح جميل!', 'أتمنى لك يوماً سعيداً!'],
      afternoon:['مساء الخير', 'مرحبا!', 'مساء جميل!', 'أتمنى لك مساءً سعيداً!'],
      evening:['مساء الخير', 'مرحبا!', 'مساء جميل!', 'تصبح على خير!'],
      night:['تصبح على خير', 'نوماً هنيئاً!', 'أحلام سعيدة!', 'أراك غداً!']
    },
    hi:{
      morning:['सुप्रभात', 'नमस्ते!', 'शुभ दिन!', 'आपका दिन शुभ हो!'],
      afternoon:['नमस्ते', 'नमस्कार!', 'शुभ दोपहर!', 'आपका दिन शुभ हो!'],
      evening:['शुभ संध्या', 'नमस्ते!', 'शुभ शाम!', 'शुभ रात्रि!'],
      night:['शुभ रात्रि', 'सुखद निद्रा!', 'सुंदर सपने!', 'कल मिलते हैं!']
    }
  };

  function pickLang(data){
    let code = '';
    const langs = data?.languages;
    if (Array.isArray(langs) && langs.length) {
      code = String(langs[0]).toLowerCase();
    } else if (typeof langs === 'string') {
      code = (langs.split(/[,; ]/).find(Boolean) || '').toLowerCase();
    }
    if (code.includes('-')) code = code.split('-')[0];
    if (!GREETINGS[code]) {
      const cc = (data?.country_code || '').toUpperCase();
      code = CC_TO_LANG[cc] || 'en';
    }
    if (code === 'nb') code = 'no';
    if (code.startsWith?.('zh')) code = 'zh';
    return GREETINGS[code] ? code : 'en';
  }

  function safeBuildGreeting(data){
    try {
      const tz = data?.timezone || 'UTC';
      const hour = Number(new Intl.DateTimeFormat('en-US', { hour:'numeric', hour12:false, timeZone: tz }).format(new Date()));
      const part = (hour < 5) ? 'night' : (hour < 12) ? 'morning' : (hour < 18) ? 'afternoon' : 'evening';
      const lang = pickLang(data);
      const g = GREETINGS[lang] || GREETINGS.en;
      const greetings = g[part] || GREETINGS.en[part];
      
      // If greetings is an array, randomly select one
      if (Array.isArray(greetings)) {
        return greetings[Math.floor(Math.random() * greetings.length)];
      }
      
      // Fallback for old format (single string)
      return greetings;
    } catch { return 'Hello'; }
  }

  function buildGreetSub(data){
    try{
      const tzId = data?.timezone || 'UTC';
      const localTime = new Intl.DateTimeFormat(undefined,{ timeZone: tzId, hour:'2-digit', minute:'2-digit' }).format(new Date());
      return `${localTime} • ${tzId}`;
    }catch{ return '—'; }
  }

  // Normalizers to one consistent shape
  function normalizeFromIpwho(d){
    return {
      ip: d.ip,
      country: d.country || '',
      country_code: d.country_code || '',
      city: d.city || '',
      region: d.region || '',
      latitude: d.latitude,
      longitude: d.longitude,
      timezone: d?.timezone?.id || d?.timezone || '',
      languages: d.languages,
      connection: {
        isp: d?.connection?.isp || d?.connection?.org || '',
        org: d?.connection?.org || '',
        asn: d?.connection?.asn || '',
        domain: d?.connection?.domain || ''
      }
    };
  }

  function normalizeFromIpapi(d){
    return {
      ip: d.ip,
      country: d.country_name || '',
      country_code: d.country || d.country_code || '',
      city: d.city || '',
      region: d.region || d.region_code || '',
      latitude: d.latitude,
      longitude: d.longitude,
      timezone: d.timezone || '',
      languages: d.languages || '', // ipapi sometimes returns comma list like "en"
      connection: {
        isp: d.org || d.asn_org || '',
        org: d.org || '',
        asn: d.asn || d.asn_code || '',
        domain: ''
      }
    };
  }

  // Kill-switch functions
  async function getIpQuick() {
    try {
      // Use a faster IP-only endpoint for kill-switch monitoring
      const response = await fetch('https://api.ipify.org?format=json', {cache: 'no-store'});
      const data = await response.json();
      return data.ip;
    } catch {
      // Fallback to primary endpoint
      try {
        const response = await fetch(PRIMARY_API, {cache: 'no-store'});
        const data = await response.json();
        return data.ip;
      } catch {
        return null;
      }
    }
  }

  async function killSwitchCheck() {
    if (!killSwitchActive || !currentSessionIP) return;

    try {
      const currentIP = await getIpQuick();
      
      if (!currentIP) {
        console.warn('Kill-switch: Connection error');
        return;
      }

      if (currentIP !== currentSessionIP) {
        // SECURITY ALERT - IP changed during session!
        console.warn('KILL-SWITCH TRIGGERED: IP address changed during active session!');
        
        // Get full IP data for the new IP
        try {
          const newData = await getIpData();
          
          // Create security alert entry
          const securityEntry = {
            timestamp: Date.now(),
            ip: newData.ip,
            country: newData.country,
            country_code: newData.country_code,
            city: newData.city,
            region: newData.region,
            connection: {
              isp: newData.connection?.isp || null,
              org: newData.connection?.org || null,
              asn: newData.connection?.asn || null,
              domain: newData.connection?.domain || null
            },
            timezone: newData.timezone || null,
            securityAlert: true // Mark as security alert
          };
          
          appendHistory(securityEntry);
          
          // Update UI with new data
          fillUI(newData);
          
          // Show security alert badge with other change badges
          const hist = getHistory();
          const lastEntry = hist[hist.length - 2]; // Previous entry before security alert
          diffBadges(lastEntry, newData, true);
          
          // Re-render history to show the security alert
          renderHistory();
          
          // Update current session IP to continue monitoring
          currentSessionIP = newData.ip;
          
        } catch (error) {
          console.error('Failed to get full data for security alert:', error);
        }
      }
    } catch (error) {
      console.error('Kill-switch check failed:', error);
    }
  }

  function startKillSwitch(initialIP) {
    currentSessionIP = initialIP;
    killSwitchActive = true;
    
    // Start monitoring every 5 seconds
    killSwitchInterval = setInterval(killSwitchCheck, KILL_SWITCH_INTERVAL);
    
    console.log('Kill-switch activated for IP:', initialIP);
  }

  function stopKillSwitch() {
    killSwitchActive = false;
    currentSessionIP = null;
    
    if (killSwitchInterval) {
      clearInterval(killSwitchInterval);
      killSwitchInterval = null;
    }
  }

  async function getIpData(){
    // Try primary
    try{
      const r = await fetch(PRIMARY_API, {cache:'no-store'});
      const j = await r.json();
      if (!j || j.success === false) throw new Error(j?.message || 'Primary failed');
      return normalizeFromIpwho(j);
    }catch(_){
      // Fallback provider
      try{
        const r2 = await fetch(FALLBACK_API, {cache:'no-store'});
        const j2 = await r2.json();
        if (!j2 || j2.error) throw new Error(j2?.reason || 'Fallback failed');
        return normalizeFromIpapi(j2);
      }catch(e2){
        throw e2;
      }
    }
  }

  function fillUI(data){
    $('greeting').textContent = safeBuildGreeting(data);
    $('greetSub').textContent = buildGreetSub(data);
    renderFlag(data.country_code); setFavicon(data.country_code);

    setKV('ip', data.ip || '—');
    setKV('country', `${data.country || '—'}${data.country_code ? ` (${data.country_code})` : ''}`);
    setKV('place', [data.region, data.city].filter(Boolean).join(' / ') || '—');
    setKV('isp', data.connection?.isp || data.connection?.org || '—');
    setKV('asn', data.connection?.asn || '—');
    setKV('tz', data.timezone || '—');

    // IPv6 check merged into IP card
    (async ()=>{
      try {
        const v6res = await fetch(IPV6_URL, {cache:'no-store'});
        if (!v6res.ok) throw new Error('No IPv6');
        const v6 = await v6res.json();
        const ipv4Text = data.ip || '—';
        const ipv6Text = `IPv6: ${v6.ip}`;
        $('ip').innerHTML = `<div class="ip-multi">
          <span title="${ipv4Text}">${truncateText(ipv4Text, 20)}</span>
          <small title="${ipv6Text}">${truncateText(ipv6Text, 25)}</small>
        </div>`;
      } catch {
        const ipv4Text = data.ip || '—';
        const ipv6Text = 'IPv6: Not detected';
        $('ip').innerHTML = `<div class="ip-multi">
          <span title="${ipv4Text}">${truncateText(ipv4Text, 20)}</span>
          <small title="${ipv6Text}">${truncateText(ipv6Text, 25)}</small>
        </div>`;
      }
    })();

    if (typeof data.latitude === 'number' && typeof data.longitude === 'number'){
      initMapBg(data.latitude, data.longitude);
      initMiniMap(data.latitude, data.longitude);
    }
  }

  async function init(){
    console.log('IPoint: Starting initialization...');
    
    // Initialize theme first
    initTheme();
    
    const dev = deviceInfo();
    setKV('ua', dev.ua);

    // Try both providers with normalization
    try{
      console.log('IPoint: Fetching IP data...');
      const data = await getIpData();
      console.log('IPoint: IP data received:', data);

      // change badges vs last
      const hist = getHistory();
      const last = hist[hist.length - 1];
      diffBadges(last, data);

      fillUI(data);

      // Save visit (normal entry, not security alert)
      appendHistory({
        timestamp: Date.now(),
        ip: data.ip,
        country: data.country,
        country_code: data.country_code,
        city: data.city,
        region: data.region,
        connection: {
          isp: data.connection?.isp || null,
          org: data.connection?.org || null,
          asn: data.connection?.asn || null,
          domain: data.connection?.domain || null
        },
        timezone: data.timezone || null,
        securityAlert: false
      });

      renderHistory();
      
      // Start kill-switch monitoring
      startKillSwitch(data.ip);
      
      // Load customization settings after everything is set up
      setTimeout(() => {
        loadSettings();
      }, 100);
      
    }catch(err){
      console.error('IPoint: Error during initialization:', err);
      // Never reference an undefined `data` here.
      $('greeting').textContent = safeBuildGreeting({ timezone: 'UTC' });
      $('greetSub').textContent = buildGreetSub({ timezone: 'UTC' });
      $('flag').innerHTML = '';
      // keep existing history visible
      renderHistory();
      
      // Load customization settings even if data loading failed
      setTimeout(() => {
        loadSettings();
      }, 100);
    }
  }

  document.getElementById('clearBtn')?.addEventListener('click', () => {
    if(confirm('Clear all saved visit history?')){
      localStorage.removeItem(KEY); renderHistory(true);
      const b = document.createElement('span'); b.className='badge'; b.textContent='History cleared';
      $('changeBadges').innerHTML=''; $('changeBadges').appendChild(b);
    }
  });

  document.getElementById('exportBtn')?.addEventListener('click', () => {
    const data = getHistory(); const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
    const url = URL.createObjectURL(blob); const a = document.createElement('a');
    a.href = url; a.download = 'ip-history.json'; document.body.appendChild(a); a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); },0);
  });

  (function attachHeaderClicks(){ document.getElementById('histHead').addEventListener('click', (e)=>{ const th=e.target.closest('th[data-key]'); if(!th) return; setSort(th.getAttribute('data-key')); }); })();

  // Parallax effect for background map
  let ticking = false;
  function updateParallax(e) {
    if (!ticking) {
      requestAnimationFrame(() => {
        const x = (e.clientX / window.innerWidth - 0.5) * 20; // Max 10px movement each direction
        const y = (e.clientY / window.innerHeight - 0.5) * 20;
        const mapbg = document.getElementById('mapbg');
        if (mapbg) {
          mapbg.style.transform = `translate(${x}px, ${y}px)`;
        }
        ticking = false;
      });
      ticking = true;
    }
  }
  
  document.addEventListener('mousemove', updateParallax);

  // Global click handler to close popup when clicking elsewhere
  document.addEventListener('click', (e) => {
    if (currentPopup && !e.target.closest('.date-cell') && !e.target.closest('.date-popup')) {
      hidePopup();
    }
  });

  // Clean up kill-switch on page unload
  window.addEventListener('beforeunload', () => {
    stopKillSwitch();
  });

  // PWA Service Worker Registration
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      // Create a simple service worker inline
      const swCode = `
        const CACHE_NAME = 'ipoint-v2.6.1';
        const urlsToCache = [
          '/',
          'https://cdn.jsdelivr.net/npm/flag-icons/css/flag-icons.min.css',
          'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css',
          'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js'
        ];

        self.addEventListener('install', event => {
          event.waitUntil(
            caches.open(CACHE_NAME)
              .then(cache => cache.addAll(urlsToCache))
              .then(() => self.skipWaiting())
          );
        });

        self.addEventListener('activate', event => {
          event.waitUntil(
            caches.keys().then(cacheNames => {
              return Promise.all(
                cacheNames.map(cacheName => {
                  if (cacheName !== CACHE_NAME) {
                    return caches.delete(cacheName);
                  }
                })
              );
            }).then(() => self.clients.claim())
          );
        });

        self.addEventListener('fetch', event => {
          if (event.request.url.includes('ipwho.is') || 
              event.request.url.includes('ipapi.co') || 
              event.request.url.includes('ipify.org') ||
              event.request.url.includes('flagsapi.com')) {
            // Don't cache API requests - always fetch fresh
            return;
          }
          
          event.respondWith(
            caches.match(event.request)
              .then(response => {
                if (response) {
                  return response;
                }
                return fetch(event.request);
              })
          );
        });
      `;

      const blob = new Blob([swCode], { type: 'application/javascript' });
      const swUrl = URL.createObjectURL(blob);

      navigator.serviceWorker.register(swUrl)
        .then(registration => {
          console.log('PWA: Service Worker registered successfully');
        })
        .catch(error => {
          console.log('PWA: Service Worker registration failed');
        });
    });
  }

  // PWA Install Prompt
  let deferredPrompt;
  window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    // Could show an install button here if desired
  });

  // Handle app installation
  window.addEventListener('appinstalled', () => {
    console.log('PWA: App was installed successfully');
    deferredPrompt = null;
  });

  // Make functions globally available
  window.toggleTheme = toggleTheme;
  window.toggleSpeedTest = toggleSpeedTest;
  window.startSpeedTest = startSpeedTest;
  window.stopSpeedTest = stopSpeedTest;
  window.openSettings = openSettings;
  window.closeSettings = closeSettings;
  window.changeThemeMode = changeThemeMode;
  window.updateAccentColor = updateAccentColor;
  window.toggleDragDrop = toggleDragDrop;
  window.resetWidgetOrder = resetWidgetOrder;
  window.exportSettings = exportSettings;
  window.importSettings = importSettings;
  window.saveSettings = saveSettings;
  window.resetAllSettings = resetAllSettings;

  init();
</script>

</body>
</html>
